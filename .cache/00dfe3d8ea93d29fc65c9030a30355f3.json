{"dependencies":[],"generated":{"js":"/**\n *        simple state management http://vuetips.com/simple-state-management-vue-stash\n * \n */\n'use strict'\n\n/*const Dexie = require('./vendor/Dexie.2.0.1.js'),\n      Vue = require('./vendor/Vue.2.5.13.js')*/\n\nconst serverURL = 'https://shopp.glitch.me/'\nconst initalCountryData = [{\n     name: 'all countries' , \n     cities: [\n               {\n                    name: 'all cities', \n                    shops:[{\n                              name: 'all shops',\n                              products: [\n                                        {\"name\":\"magazine\"},\n                                        {\"name\":\"daily tabloid\"},\n                                        {\"name\":\"plastic bag\"}\n                              ]\n                    }]\n               }\n     ]\n}]\n\n\n\n//window.otherUsers = []\n//window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;\n\n\nconst deviceUserData = new Dexie('deviceUserData')\n\n     deviceUserData.version(1).stores({  userData: 'userName, countries'  })\n     deviceUserData.open()\n     .then(result =>{\n               //console.log('open own DB, data:', result)\n     })\n     .catch(function(error) {\n               console.error('Uh oh : ' + error);\n     });\nconsole.log(window.webkitIndexedDB)\n\n\nconst users_followed = new Dexie('users_followed')\n      users_followed.version(1).stores({ userData: 'email, userName, countries'})\n      users_followed.open()\n      .catch(error => {\n               console.error('Uh oh : error opening Users_followed db' + error);\n      });\n     \n     //const user1data = require('./testUserData1.json'), user2data = require('./testUserData2.json')\n     //users_followed.userData.put(user1data)\n     //users_followed.userData.put(user2data)\n\n\nconst picturesDB = new Dexie('product_img')\n      picturesDB.version(1).stores({item: 'fileName, userName, data'})  // filename contains email\n      picturesDB.open()\n      .catch(er=>console.error('couldnt open DB',er))\n      \n\n\n\n\nconst app = new Vue({\n     el: '#app',\n     data: {\n          screen:'main',\n          showSignUp: false,\n          showLogin: false,\n          seeSignUp: false,\n          loginemail: null,\n          loginpass: null,\n\n          searchText: null,\n          searchResults: null,\n          followedUsers: getLSfollowedUsers(),\n\n          showSettings: false,\n          userName: undefined,\n          console: undefined,\n          locationInputShown: false,\n          locationSet: null,\n          newLocation: null,\n\n          currentCountry: null,\n          currentCity:  null,\n          currentShop:  null,\n          countries: [],\n          cities: [],\n          shops: [],\n          //currentDisplayedProducts: [],\n\n          mouseMillis: 0,\n          newProductForm: false,\n          newProductPreview: false,\n          newProductPreviewLastModified: null,\n          newProductType: null,\n          newProductName: null,\n          newProductDescription: null,\n          newProductDescriptionLong: null,\n          newProductPrice: null,\n\n          modifyingProduct: false,\n          productModified: null,\n          animateLoader: false,\n\n          fetchPicsAlso: false,\n          autoFetchOthersData: (localStorage.getItem('autoFetchOthersData')=='true') ? true : false,\n          autoFetchOthersImages: (localStorage.getItem('autoFetchOthersImages')=='true') ? true : false,\n     },\n     methods:{\n          switchScreen:function(screen){\n               this.screen = screen\n\n               if (screen =='main'){\n                    this.locationInputShown = false\n                    this.locationSet = null\n                    this.newLocation = null\n\n                    this.newProductForm = false;\n               }\n          },\n          showUserSettings:function(show){\n               this.showSettings = show;\n               if (show) this.screen = 'settings'\n               else this.screen = 'main'\n          },\n          onLine:function(){\n               \n               if (navigator.onLine) return true\n               else return false\n          },\n          login:function(){\n               let email = this.loginemail,\n                   password = this.loginpass\n\n               console.log('loginin', email, password)\n\n               const tosend = {email, password}, self = this\n\n               animateLoader.call(this)\n\n               const xhr = new XMLHttpRequest()\n               xhr.onreadystatechange = function() {\n\n                    if (this.readyState == 4 && this.status == 200) {      console.log('received',typeof this.responseText, this.responseText)\n\n                         let LSitems = ['deviceUserEmail', 'deviceUser', \n                                        'autoFetchOthersData','autoFetchOthersImages', 'hasToken',\n                                        'followedUsers', 'countries',\n                                        'cities', 'shops']\n                         LSitems.forEach(item=> window.localStorage.removeItem(item) )\n\n                         let loginResponse\n                              \n                         if (typeof this.responseText==='string') loginResponse = JSON.parse(this.responseText)\n\n                         window.localStorage.setItem('deviceUserEmail', email)\n                         if (loginResponse.hasToken == 1) window.localStorage.setItem('hasToken', loginResponse.hasToken )\n                         updateDeviceUser(loginResponse.userName)     // stores userName and login date\n                              \n                         if (loginResponse.followedUsers) // this doesnt store their country data\n                                   loginResponse.followedUsers.forEach(user=>addUserNameToFollowed(user))\n\n                         self.userName = loginResponse.userName\n\n                         self.informUser(`You hip'n'roll! Now logged iN`) // rock'n'hop\n\n                         self.screen = 'main'\n                         stopLoaderAnimation.call(self)\n\n                         return self.startApp()\n\n                    } else if (this.readyState == 4 && this.status !== 200){\n\n                         stopLoaderAnimation.call(self)\n                         self.informUser(`something went wrong, try again`)\n                    }\n               }\n               xhr.open(\"POST\", serverURL + \"API/login\", true)\n               xhr.send(JSON.stringify( tosend))\n\n          },\n          signUp: function($event){\n               $event.preventDefault()\n\n               const self = this\n               let email = document.querySelector('input[name=\"reg-useremail\"').value,\n                   userName = document.querySelector('input[name=\"reg-username\"').value,\n                   password  = document.querySelector('input[name=\"reg-userpassword\"').value\n\n               if (userName==0) return alert(`sorry, '${userName}' can't be accepted as username`) // 0 is reserved for unregistered user in IDB\n\n               const tosend = {email, userName, password}\n               \n\n               if (!email || !userName || ! password) return console.error('email or name or pass missing')\n\n               animateLoader.call(this)\n\n               const xhr = new XMLHttpRequest()\n               xhr.onreadystatechange = function() {\n                    \n                    if (this.readyState == 4 && this.status == 200) {  //this.responseText;\n                              //console.log(this.responseText,this.status)\n\n                              self.informUser(`You rock'n'b! Account created, check your email, spam etc`)\n                              window.localStorage.setItem('deviceUserEmail', email)\n\n                              updateDeviceUser(userName)    // stores userName and login date to local storage\n                              \n                              self.userName = getDeviceUser()\n                              self.screen = 'main'\n\n                              return self.startApp()\n\n                    } else if (this.readyState == 4 && this.status ==400)\n\n                              self.informUser(`Email address '${email}' is already used..`)\n                    else {}\n               };\n\n               xhr.open(\"POST\", serverURL + \"API/signup\", true)\n               xhr.send( JSON.stringify(tosend))\n          },\n          logout: function($ev){\n               console.log('>> logouted <<')\n               \n               let items = ['deviceUserEmail', 'deviceUser', \n               'autoFetchOthersData','autoFetchOthersImages', 'hasToken',\n               'followedUsers', 'countries',\n               'cities', 'shops']\n\n               items.forEach(item => window.localStorage.removeItem(item) )\n               \n               //this.userName = undefined\n               console.log('now will reload app')\n               return this.startApp()\n          },\n          requestDropboxAccess:function(){\n               \n               const url = 'https://www.dropbox.com/oauth2/authorize?' + \n                         'response_type=token&' +\n                         'client_id=hqdb69ima3zv29t&' +\n                         'redirect_uri=' + window.location.origin + '/'    //'http://localhost:1234/'\n\n               window.location.href = url\n          },\n          fetchMyCountries:function(){\n               console.log('fetching device countries of >', this.userName, '<')\n               animateLoader.call(this)               \n               const errorHandlerLocal = errorHandler.bind(this)\n\n               fetchCountriesOfUser({   userName: this.userName,\n                                        email: localStorage.getItem('deviceUserEmail')\n               }).then( userData =>{\n\n                    console.log('|||  userData fetched', userData)\n                    return updateDeviceUserCountries(this.userName, userData.countries)\n                    \n               })\n               .then( resultCountries => {\n                    console.log('saved user own data', resultCountries)\n\n                    if (this.fetchPicsAlso){\n\n                         let picsNamesAndURLs;\n                         getListOfImgNamesAndURLs(resultCountries)\n                         .then(namesAndURLs=>{\n                              \n                              picsNamesAndURLs = namesAndURLs\n                              //const urlsOnly = namesAndURLs.map(obj=>obj.url)\n                              const imgData = namesAndURLs.map(obj=>obj.url).map(fetchDbxImage)\n                              return Promise.all(imgData)\n\n                         }).then(dataOfImgs=>{ // array of raw data strings\n                              \n                              dataOfImgs = dataOfImgs.map((dataURL,i)=>{\n                                             return { imgName: picsNamesAndURLs[i].imgName, data: dataURL, userName: this.userName}\n                                           })\n\n                              const promises = dataOfImgs.map( img => saveImageToIDB(img.imgName, img.data, this.userName) )\n                              return Promise.all(promises)\n                         })\n                         .then( imageNames =>{\n\n                              stopLoaderAnimation.call(this)\n                              this.switchScreen('main')\n                              return this.startApp()\n                         })\n                         .catch(errorHandlerLocal)\n\n\n                    } else {\n\n                         stopLoaderAnimation.call(this)\n                         this.informUser(`Sukces - your own data updated!`,2500)\n\n                         this.switchScreen('main')\n                         return this.startApp()\n                    }\n                    \n                    \n               }).catch(errorHandlerLocal)\n\n               \n          },\n          pushMyCountries:function(){\n               if (!this.userName ) return alert('unregistered user cant back up data online')\n               if (!navigator.onLine) return alert(`ooops, you're not online..`)\n\n               console.log('pushing my countries', this.userName)\n               const email = localStorage.getItem('deviceUserEmail')\n\n               sendCountryDataOfUser({email, userName: this.userName})\n               .then(()=>{\n\n               })\n               .catch(er=>{\n                    this.informUser(`Didnt work out as planned. Try again?`)\n               })\n          },\n          changeAutoFetchOthersData:function(){\n               this.autoFetchOthersData = !this.autoFetchOthersData\n               console.log( 'saveing? ' , this.autoFetchOthersData)\n               localStorage.setItem('autoFetchOthersData', this.autoFetchOthersData)\n\n               /*if (this.autoFetchOthersData===true) {\n                    console.log('images?', localStorage.getItem('autoFetchOthersImages') )\n                    this.autoFetchOthersImages = localStorage.getItem('autoFetchOthersImages')\n               } else this.autoFetchOthersImages = false*/\n          },\n          changeAutoFetchOthersImages:function(){\n               this.autoFetchOthersImages = !this.autoFetchOthersImages\n               localStorage.setItem('autoFetchOthersImages', this.autoFetchOthersImages)\n          },\n          requestUsers:function(){\n               let string = this.searchText\n               const self = this\n               console.log('search for:', string)\n\n               const xhr = new XMLHttpRequest()\n               xhr.onreadystatechange = function(){\n                    if (this.readyState == 4 && this.status == 200) { \n\n                         //console.log('recevide', this.responseText, typeof this.responseText)\n                         const users = JSON.parse(this.responseText)\n                         console.log(users)\n                         self.searchResults = users\n                    }\n               }\n               xhr.open('GET', serverURL + 'API/search?string=' + string + \"&useremail=\" + window.localStorage.getItem('deviceUserEmail'), true)\n               xhr.send( string)        // useremail is added to server can remove user himself from search results\n\n          },\n          informUser: function(msg, millis = 3000){\n               this.console = msg\n\n               setTimeout(()=>{\n                    this.console = undefined\n               },millis)\n          },\n          followUser:function(email,userName){\n               console.log('follow', email,userName)\n               const self = this\n               const xhr = new XMLHttpRequest()\n               animateLoader.call(this)\n\n               xhr.onreadystatechange = function(){\n\n                    if (this.readyState == 4 && this.status == 200) { \n                         console.log('follow sekces')\n                         \n                         addUserNameToFollowed({userName, email})    // store new followdee in local storage\n\n                         fetchCountriesOfUser({userName, email})\n                         .then(setOtherUserIDBData)              // hard-replaces whole document with new data\n                         .then(self.startApp)                    // here it copies data(countries etc) to device users\n                         .catch(er=>stopLoaderAnimation.call(self))\n\n                    } else if (this.readyState == 4 && this.status != 200) { \n                         stopLoaderAnimation.call(self)\n                         console.error('TRY AGAIN LATER')\n                         this.informUser('TRY AGAIN LATER')\n                         // finish this part\n                    }\n               }\n               xhr.open('POST', serverURL + 'API/followuser', true)\n               xhr.send(JSON.stringify({  email, \n                                          userName,\n                                          addTo: window.localStorage.getItem('deviceUserEmail')\n                                       })\n               )\n\n          },\n          isFollowed:function(email){\n                    let users = JSON.parse(  window.localStorage.getItem('followedUsers')  )\n                    //console.log('search for',email, 'LS followed users', users)\n\n                    if (!users || users.some(user=>user.email== email)===false) return false\n                    else return true\n          },\n          unfollowUser:function(user){\n               console.log(`>> unfollowing ${user.userName} <<`)\n               // delete local storage country data of that user only if he isnt followed by any other deviceUser in IDB\n          },\n          openLocationInput: function(set,ev){\n               this.locationInputShown = true\n               //console.log('event', set, ev)\n               this.locationSet = `${set}`\n\n               if (this.locationSet=='city' && this.currentCountry == 'all countries') {\n                    alert('choose country first')\n                    return this.locationInputShown = false\n               }\n          },\n          addNewLocation: function(){\n               \n               if (!this.newLocation || this.newLocation=='') return this.informUser('no name?',1500)\n               if (this.newLocation == 'all countries' || this.newLocation == 'all cities' || this.newLocation == 'all shops'){\n                         this.informUser(`sorry, '${this.newLocation}' is one of names that are not allowed`,3000)\n                         return this.newLocation = ''\n               }\n               //console.log(`new ${this.locationSet} is ${this.newLocation}`)\n\n               const addLocation = addNewLocationToDB.bind(this)\n\n               return addLocation( this.locationSet, this.newLocation.toString() )\n          },\n          updateLocationSelect:function(index, event,requestedShopName){\n               //console.log('slct', event.srcElement.selectedIndex)\n               //console.log('event','>',requestedShopName,'<')//'\\n', event.srcElement.getAttribute('data-saveas')  )\n\n               if (event && event.srcElement.selectedIndex<0) return;      // protection against DOM load events ?\n\n               const self = this\n               const selects = ['countries', 'cities', 'shops','products'],\n                     currents= ['currentCountry','currentCity','currentShop']\n               let name\n               if (event) {\n                    name = event.srcElement.selectedOptions[0].text\n                    setLastSelection(event.srcElement.getAttribute('data-saveas'), name)\n\n               } else name = requestedShopName\n               \n               //return console.log('name', name, 'event', event)\n               \n               getSubsetItems(this,index,name)\n                    .then(initialOwnProducts =>{\n                         // save last locations to local storage rather here?\n                         return;\n\n                         // none of the below is needed now\n                         const userOwnProducts = initialOwnProducts.map(prod=>{prod.owner = this.userName || 0; return prod})\n                         console.log('----- user own products:', userOwnProducts.length, userOwnProducts)\n\n                         // get products from each user in IDB: for current city, shop etc\n                         getOtherUsersIDBData(this.followedUsers)\n                         .then(users=>{\n                              console.log('users to add products from', users)\n\n                              let finals = []\n                              if (userOwnProducts.length>0) finals = [...userOwnProducts]\n\n                              console.log('finals1', finals.length)\n\n\n                              if (users){\n                                   let otherProds = users.map(user=>{\n\n                                        const countryI = user.countries.findIndex(cntry => cntry.name === self.currentCountry)\n\n                                        if (countryI > -1){\n                                             \n                                             const cityI = user.countries[countryI].cities.findIndex(city=>city.name === self.currentCity )\n                                             //console.log('cityI', cityI)\n                                             const shop = user.countries[countryI].cities[cityI].shops.find(shop=>shop.name===self.currentShop)\n                                             //console.log('shop', shop)\n                                             if (shop && shop.products) return shop.products\n                                        }\n                                   }).filter(prods=>prods!==undefined)\n\n                                   if (otherProds.length>0) finals = finals.concat(...otherProds)\n                              }\n                              console.log('finals', finals)\n\n                              /*return new Promise((resolve, reject)=>{\n                                   \n                                   resolve (this.currentDisplayedProducts = finals ) // display products on screen\n\n                                   // check out vue cheatsheet (v-bind) to see how to attach classes\n                              })*/\n                              return finals\n                               \n                         })\n                         .then(finals=>{\n                              console.log('finals2', finals)\n\n                              let prodsWImages = finals\n                                                  .filter(prod=>!!prod.imgName)\n                                                  .map(prod=>prod.imgName)\n\n                              /*let imgNames = document.querySelectorAll('div.product p.prodImgData')\n                                   let onlyNames = nodeListToArray(imgNames)*/\n                                   //console.log(imgNames, 'onlyNames', onlyNames)\n\n\n                              //\n                              return getImgIDBDataOf(prodsWImages)\n                              \n                         })\n                         // give images their data\n                         .then(urls=>{\n                              let els = document.querySelectorAll('div.product img'),\n                              images = nodeListToArray(els)\n\n                              /** from docs\n                               * <!-- bind an attribute -->\n                                 <img v-bind:src=\"imageSrc\">\n                               */\n                              \n                              //console.log('??urls??', urls)\n                              images.map((image,i)=>image.src = urls[i])\n                         })\n                    })\n               function getSubsetItems(self, outerIndex, name){\n                    \n                    if (outerIndex>4) return console.error('outerIndex>4  !!!',outerIndex) // this doesnt seem to ever happen\n                    \n                    return new Promise((resolve, rej)=>{\n                         // 0 1 2\n                         const currentX = currents[outerIndex]  // 'currentCountry' 'currentCity' 'currentShop'\n                         const index = outerIndex,\n                               superSet = selects[index-1], // 'countries' 'cities' 'shops'\n                               set      = selects[index],   // 'countries' 'cities' 'shops'\n                               subSet   = selects[index+1]  // 'countries' 'cities' 'shops'\n                               \n                         let a = self[set].find(el=> el.name===name )\n                         \n                         \n                         self[currentX] = name\n                         setLastSelection(set, name)\n                         console.log('current',currentX, name)\n                         \n                         \n\n                         self[subSet] = a[subSet]\n                         //console.log('subSet', subSet)\n                         \n                         if (currents[outerIndex+1]=== undefined) {\n                              //console.log('products?', a.name, a[subSet])\n                              resolve(a[subSet]) \n                         }\n                         else {\n                              let string = currents[outerIndex+1].toString()\n                              self[string]= a[subSet][0].name    // 'currentCountry' 'currentCity' 'currentShop'\n                              \n                              resolve(\n                                   getSubsetItems(self, outerIndex + 1, a[subSet][0].name)          \n                              )\n                         }\n                    })\n               }\n          },\n          startTimer:function(prod){\n               //console.log('start timer')\n               const self = this\n               window.mouseTimer = setInterval(()=> self.mouseMillis += 10 ,10)\n          },\n          stopTimer:function(ev, prod){\n               \n               clearInterval(window.mouseTimer)\n\n               if (this.mouseMillis>300) this.openProductFormToModify(prod)\n               \n               this.mouseMillis = 0\n          },\n          enlargeImage:function(ev){\n               //console.log('enlarging image', ev)\n               const textDiv = ev.path[2]\n\n               if (ev.srcElement.className==\"\") ev.srcElement.className = 'large'\n                    //textDiv.className = 'fadeAway'\n\n               else ev.srcElement.className =\"\" \n                    //textDiv.className = \"\"\n               \n          },\n          openProductForm:function(open){\n\n               if (open===true && !navigator.onLine) return this.informUser(`You can't add products offline. Take a picture now and add a product when you are online.`,7000)\n               \n               this.newProductForm = open\n\n               if (open === false){\n                    this.newProductPreview= false\n                    this.newProductPreviewLastModified= null\n                    this.newProductType= null\n                    this.newProductName= null\n                    this.newProductDescription= null\n                    this.newProductDescriptionLong= null\n                    this.newProductPrice= null\n\n                    removeFormRatingChecked()\n\n                    this.modifyingProduct= false\n                    this.productModified= null\n                    this.modifyingProduct = false;\n               }\n          },\n          newProductSubmit: function($event){\n               $event.preventDefault()\n               \n               if (!this.newProductPreview) \n                         return this.informUser(`picture of product is required`,2000)\n               if (!this.newProductType || !this.newProductName ) \n                         return this.informUser(`product type and name are required`,3000)\n               if (! document.querySelector('input[name=\"newRating\"]:checked')) \n                         return this.informUser('select product rating',2500)\n\n\n               const rating = document.querySelector('input[name=\"newRating\"]:checked').value\n\n               const fileName =`${window.localStorage.getItem('deviceUserEmail')\n                               }_D${getFormattedDate(this.newProductPreviewLastModified)}`\n\n               //console.log('submit', fileName)\n               //console.log(this.newProductType, this.newProductName, this.newProductDescription, this.newProductPrice, rating)\n               const fieldnames=['descr','descrLong','price'],\n                     otherFields = [this.newProductDescription, this.newProductDescriptionLong, this.newProductPrice]\n\n               const productToAdd = {\n                    imgName: fileName,\n                    type: this.newProductType,\n                    name: this.newProductName,\n                    rating\n               }\n               let voluntaryFields = otherFields.map(field=>{ \n                                             if (!!field && field.toString().trim()!=='') return field\n                                             else return null \n               })\n               \n               voluntaryFields.forEach((field,i)=>{\n                                   if (field) productToAdd[fieldnames[i]] = field.toString().trim()\n               })\n               console.log('product to add\\n', productToAdd)\n\n               const uploadToDBX = uploadImgToDropbox.bind(self),\n                     addProduct = addNewLocationToDB.bind(this),\n                     hasToken = localStorage.getItem('hasToken')\n\n               console.log('hasToken?',hasToken)\n\n               if (navigator.onLine && hasToken==1) // upload image to dbx\n\n                         uploadToDBX(fileName, window.toUploadToDropbox)\n                         .then(link =>{\n                                   \n                                   console.log('link', link)\n                                   productToAdd.dbxURL = link\n\n                              return saveImageToIDB(fileName, window.canvasData, this.userName)\n                         })\n                         .then(result =>{\n                              console.log('result 2', result)\n                              window.toUploadToDropbox = undefined\n\n                              if (result) return result\n                         })\n                         .then(y => addProduct('product', productToAdd) )\n                         .then(()=>{\n                              \n                              this.newProductForm = false\n                              this.newProductPreview = false\n                              this.reloadView()\n                         })\n                         .catch(er=>alert('huge arror storing new product'))\n               \n\n               else saveImageToIDB(fileName, window.canvasData, this.userName)\n               .then(()=>{\n                    window.toUploadToDropbox = undefined\n                    // create task to upload image when user is online\n                    // return createUploadTaks\n               })\n               .then(()=> addProduct('product', productToAdd) )\n               .then(()=>{\n                    window.canvasData = null\n                    this.newProductForm = false\n                    this.newProductPreview = false\n                    return this.reloadView()\n               })\n               .catch(er => console.error('ERROR', er))\n\n               \n\n               \n          },\n          imageAdded:function(ev){\n\n                    const reader = new FileReader(),\n                         readBin = new FileReader(),\n                         self = this,\n                         file = ev.target.files[0]\n                    // getPicDate(file.lastModifiedDate || file.lastModified) // lastMod is epoch time on nonSafari\n                    this.newProductPreviewLastModified = file.lastModified    // when storing pic to IDB, its part of filename\n                    console.log(file)\n\n                    reader.onload = function(fileObj){\n                         let img = new Image()\n\n                         //let data = fileObj.target.result\n                         \n                         img.onload = function(){\n\n                              if (this.width>this.height) return alert(`take image with vertical orientation please`)\n\n                              let fract = 10\n                              let wid = 300     //parseInt(  this.width/fract),\n                                  //,hei = 300  //parseInt(  this.height/fract)\n                              \n\n                              const canvas = document.querySelector('canvas'),\n                                   ctx = canvas.getContext('2d'),\n                                   start = Math.floor( (this.height-this.width)/2 )\n                              canvas.width = wid\n                              canvas.height = wid\n\n\n                                             //  sX  sY     sW          sH                       \n                              ctx.drawImage(this,0,  start, this.width, this.width,  0,0, wid, wid)\n\n                              console.log(' canvas len', canvas.toDataURL().length/1024)\n                              console.log('preview len',img.src.toString().length/1024)\n\n                              self.newProductPreview = true\n\n                              window.canvasData = canvas.toDataURL() // canvas data for new image to save to IDB\n\n                              canvas.toBlob(function(blob){\n                                   \n                                   let reader = new FileReader()\n                                   reader.onloadend = function(){\n                                        console.log('binary result', reader.result)//, reader.result.substr(0,100) + '...')\n                                        window.toUploadToDropbox = reader.result    // global var is used later to upload\n\n                                        //const upload = uploadImgToDropbox.bind(self)\n\n                                        //upload(undefined, reader.result,  ev.target.files[0], blob)//,\n                                        //uploadImgToDropbox(undefined, reader.result)\n                                   }\n                                   reader.readAsArrayBuffer(blob)    //reader.readAsBinaryString(blob)\n                              })\n                         }\n                         img.src = fileObj.target.result\n                    }\n                    \n                    reader.readAsDataURL(ev.target.files[0])\n                    //this.newProductForm = false\n          },\n          openProductFormToModify:function(prod){\n               \n               if (!prod.owner) return this.informUser(`You can only modify your own products`,1500)\n               console.log('modify',prod)\n\n\n               this.modifyingProduct = true // to show correct submit button\n               this.productModified = prod\n\n               if (prod.type) this.newProductType = prod.type\n               if (prod.name) this.newProductName = prod.name\n               if (prod.descr) this.newProductDescription = prod.descr\n               if (prod.descrLong) this.newProductDescriptionLong =prod.descrLong\n               if (prod.price) this.newProductPrice = parseFloat( prod.price )\n               //removeFormRatingChecked()\n\n               if (prod.rating) document.querySelector(`input[name=\"newRating\"][value=\"${prod.rating}\"]`).setAttribute('checked', true)\n                    \n               // just showing product's image\n               if (prod.imgName) getImgIDBDataOf([prod.imgName])   \n               .then(data=>{\n                    const self = this,\n                          img = new Image(),\n                          canv = document.querySelector('canvas'),\n                          ctx = canv.getContext('2d')\n\n                    img.onload = function(){\n                         ctx.drawImage(this,0,0,300,300)\n                         self.newProductPreview = true\n                    }\n                    img.src = data\n               })\n               this.newProductForm = true\n\n          },\n          applyProductChanges:function(ev){\n               ev.preventDefault()\n               console.log('prod change', this.productModified)\n\n               \n               getOwnIDBData(this.userName)\n               .then(ownData=>{\n                    //console.log('    ownData',ownData)\n                    //console.log(this.productModified.imgName)\n\n                    const search = findProductLocations(ownData, this.productModified.imgName)\n                    const prod = search.product\n\n                    //return console.log('locs of product', locations)\n\n                    /*let country = ownData.find(country=>country.name == this.currentCountry)\n                    let city = country.cities.find(city=> city.name == this.currentCity)\n                    let shop = city.shops.find(shop=>shop.name== this.currentShop)\n                    let prod = shop.products.find(prod=>prod.name === this.productModified.name)*/\n\n\n                    for (let prop in prod){\n                         if (prop!=='imgName' && prop!=='dbxURL') delete prod[prop]\n                    }\n               \n\n                    if ( this.newProductType) prod.type = this.newProductType\n                    if ( this.newProductName) prod.name = this.newProductName\n                    if ( this.newProductDescription) prod.descr = this.newProductDescription\n                    if ( this.newProductDescriptionLong)  prod.descrLong = this.newProductDescriptionLong\n                    if ( this.newProductPrice) prod.price = parseFloat(this.newProductPrice)\n\n                    prod.rating = document.querySelector('input[name=\"newRating\"]:checked').value\n\n                    //console.log('prod edited to:', prod)\n                    console.log('upated cntries?\\n', ownData)\n\n                    updateDeviceUserCountries(this.userName, ownData)  // returns exact same countries object\n                    .then(this.UIafterProductFormSubmitted)\n               })\n          },\n          deleteProduct:function(ev){\n               ev.preventDefault()\n\n               if (confirm('Delete this product?')){\n               \n                    //console.log('delete', this.productModified)\n                    if (!this.productModified.imgName) return this.informUser('cant delete this product', 2000)\n\n                    \n                    // using stored data, since displayed data has unnecessary temp info attached, this way it's easier\n                    getOwnIDBData(this.userName)\n                    .then(ownData=>{\n                         console.log('    ownData',ownData)\n\n                         const search = findProductLocations(ownData, this.productModified.imgName),     // find product among own prods\n                              i = search.i\n\n                         search.shop.products.splice(i,1)\n                         //return console.log('    shop prods modified?', ownData)\n\n                         deleteImageFromIDB(this.productModified.imgName)\n                         .then(()=>updateDeviceUserCountries(this.userName, ownData))\n                         .then(this.UIafterProductFormSubmitted)\n\n                         if (this.productModified.imgName && navigator.onLine) \n\n                              deleteDropboxImg( localStorage.getItem('deviceUserEmail'), this.productModified.imgName)\n                              .then(status=>this.informUser(`deleted Dropbox img: ${status}`, 3000))\n                              \n                              \n                         else if (this.productModified.imgName && !navigator.onLine){\n\n                              // create queue of files to get deleted from Dropbox\n                         }\n                         \n                    })\n               }\n          },\n          UIafterProductFormSubmitted:function(){\n               this.modifyingProduct = false    // hides Modify and Delete buttons\n               this.newProductPreview = false   // to hide canvas\n\n               this.openProductForm(false) // to reset form\n               this.reloadView()\n               return this.switchScreen('main')\n          },\n          reloadView:function(){\n                    console.log('RELOADING VIEW')\n\n               let ownCountries,\n                   othersCountriesWProds,\n                   somethingChanged = false\n\n               getOwnIDBData(this.userName)\n               .then( ownData =>{\n\n                    //ownCountries = ownData\n                    ownCountries = addOwner(ownData, this.userName || '0')  // owner key serves later when allowing/blocking user to modify product\n                    \n                    console.log('!this.followedUsers?',!this.followedUsers)\n\n                    if (!this.userName || !this.followedUsers) {\n                         \n                         ownCountries = loadProductIDBURLs(ownCountries)\n\n                         /*console.log('ownCountries with URLs', ownCountries)\n                              loadProductIDBURLs(ownCountries)\n                              .then(cntrs=>{\n                                   //console.log('cntrs',cntrs)\n                                   stopLoaderAnimation.call(this)\n                                   return initializeLocationSelects(this, cntrs)\n                              })*/\n                         return null \n\n\n                    } else return getOtherUsersIDBData(this.followedUsers)\n\n               })\n               .then(othersData=>{\n                    console.log('others data', othersData)\n                    if (othersData){\n                         let own = [...ownCountries], \n                         Users = othersData.map( user => user.countries )\n\n                         othersCountriesWProds = JSON.parse(JSON.stringify(Users))\n                         // it will be needed later in original state to show products\n                              \n                         //let woProducts = copyUserDataOrig.call(this, Users, own, 1) //return woProducts\n\n\n                         // returns Countries with added new locations from others (w/o their prods)\n                         // -> for saving them to users IDB\n                         return copyUserDataOrig.call(this, Users, own, 1)\n\n                    } else {\n                         console.log('------  other user data should be here but isnt')\n                         // in case of logging in on device where no followed users' data is stored but user actually follows someone\n                         //ownCountries = loadProductIDBURLs(ownCountries)   \n                         // show user suggestion to fetch others' data? or do it automatically?\n                         if (this.userName && this.followedUsers)\n\n                              fetchDataOfFollowedUsers.call(this)\n\n                              .then(()=> this.reloadView() )\n\n                         else return null \n                    }\n               })\n               .then(result=>{\n                    if (result){\n                         console.log('somethingChanged? ',result.somethingChanged)\n                         console.log('reloading - location w/o prods to save', result.countries)\n\n                              \n                         if (result.somethingChanged===true) \n                              // save all locations without prods to device user IDB\n                              // return updateDeviceUserCountries(this.userName, result.countries)\n                                   return result.countries\n                         //     .then(initializeLocationSelects(this, result.countries))\n\n                         else return result.countries\n                    } else return null         \n               })\n               .then(myresult=>{\n                    if (myresult){\n\n                         stopLoaderAnimation.call(this)\n\n                         let copy = JSON.parse( JSON.stringify(othersCountriesWProds))\n\n                         const withProducts = copyUserDataOrig.call(this, copy, myresult, 0)\n                         console.log('withProducts for display', withProducts)\n\n                         this.countries = withProducts.countries // update screen w new data available\n\n                         return loadProductIDBURLs(withProducts.countries)\n\n                    } else return null\n               })\n               .then(result=>{\n                    if (result){\n\n                         console.log('result w URLs',result)\n                         return initializeLocationSelects(this, result)\n\n                    } else ownCountries.then(result=>{\n\n                         console.log('!! my own countries resolved', result)\n                         initializeLocationSelects(this, result)  \n                    })\n                    \n               })\n               .catch(er=>{\n                    //console.log('ownCountries', ownCountries)\n                    console.error(er)\n                    /*ownCountries.then(result=>{\n                    })*/\n                    //stopLoaderAnimation.call(this)\n               })\n          },\n          startApp:function(){\n               //this.screen = 'main'\n\n               this.userName = getDeviceUser()\n               //if (this.userName===null) this.userName = 'null'  // because of IDB so user can be found, it doesnt store null as value\n\n               \n               if (this.userName) this.followedUsers = getLSfollowedUsers()\n               else this.followedUsers = null\n               console.log('followedUsers', this.followedUsers)\n               \n               let ownCountries\n               let somethingChanged = false\n\n               getOwnIDBData(this.userName)\n               .then( ownData =>{  \n                    console.log('start app ownData ->', ownData)\n                    if (!this.userName || !this.followedUsers || this.followedUsers.length===0){ \n                         stopLoaderAnimation.call(this)\n                         return this.reloadView()\n                         //return initializeLocationSelects(this, ownData)\n                    }\n                    ownCountries = ownData\n\n                    // get other's MDB data to update IDB\n                    if (navigator.onLine && this.autoFetchOthersData === true){\n\n                         animateLoader.call(this)  // show Loader\n\n                         fetchDataOfFollowedUsers.call(this)\n\n                         .then(()=> this.reloadView() )\n                         /*   // copied to separate function:\n                              const fetchedCountryData = this.followedUsers.map(fetchCountriesOfUser) // get new data for each followed user\n\n                              Promise.all(fetchedCountryData)\n                              .then(userData=>{   // store new user data\n\n                                   console.log('nav online - fetched', fetchedCountryData)\n                                   const saved = userData.map(user=>setOtherUserIDBData(user))\n                                   \n                                   return Promise.all(saved)\n                              }).then(saved=>{      // reloadView() is where new locations get copied to users countries\n\n                                   console.log('starting app - other users data', saved)\n                                   //stopLoaderAnimation.call(this)\n                                   return this.reloadView()     //getOtherUsersIDBData(this.followedUsers)\n\n                              }).catch(er=>console.error('error in online branch',er))\n                         */\n\n                         // finds images that should be displayed but are missing on device -> fetches and saves them to device IDB\n                         if (this.autoFetchOthersImages===true){  console.log('||| getting also images')\n                              \n                              let picsNamesAndURLs;\n                              getOtherUsersIDBData(this.followedUsers)\n                              .then(users=>{\n                                   //console.log('othersCountries',users)\n                                   users = users.map(user => getListOfImgNamesAndURLs(user.countries) )  // of other users\n                                   return Promise.all(users)\n\n                              }).then(listsOfImgNamesAndURLs=>{ // array of arrays or nulls\n                                   //console.log('idk ===', listsOfImgNamesAndURLs)    \n                                   // find only those imgs that arent already saved on device\n                                   return findImgNamesNotInIDB( listsOfImgNamesAndURLs )\n                              }).then(toFetch=>{\n                                   picsNamesAndURLs = toFetch\n                                   //const proms = toFetch.map(img)\n                                   const imgData = toFetch.map(obj=>obj.url).map(fetchDbxImage)\n                                   return Promise.all(imgData)\n                              }).then( dataOfImgs => { // array of raw data strings\n                              \n                                   dataOfImgs = dataOfImgs.map((dataURL,i)=>{\n                                                  return { imgName: picsNamesAndURLs[i].imgName, data: dataURL, userName: this.userName}\n                                                })\n                                   // save img dataURLs to IDB\n                                   const promises = dataOfImgs.map( img => saveImageToIDB(img.imgName, img.data, this.userName) )\n\n                                   return Promise.all(promises)\n                                   //return null\n                              }).then(imgNames=>{\n                                   console.log('imgNames fetched & saved?', imgNames)\n                                   return this.reloadView()\n                              })\n                              .catch(er=>this.informUser(`downloading others' images failed`)) \n                         }\n                         \n                    } else {\n                         console.log('|||  not online || dont autofetch')\n                         this.reloadView()\n                         //return getOtherUsersIDBData(this.followedUsers)  \n                    }\n\n               // this stuff doesnt ever happen now\n               }).then(users=>{\n                        \n                    if (users){\n                         console.log('my own', ownCountries)\n                         \n                         /*if (!users){   // this cant happen now\n                              console.log('NO FOLLOWED USERS')\n                              return initializeLocationSelects(this, ownCountries)\n                         }*/\n\n                         let \n                             own = [...ownCountries],\n                             Users = users.map(user=>user.countries)\n\n                         const copyFunc = copyUserDataOrig.bind(this)\n                         console.log('|||  equal? ', copyFunc == copyUserDataOrig, copyFunc === copyUserDataOrig)\n                         const copy = copyFunc.call(this, Users, own, 0)\n\n                         // copies all others' locations to save them in IDB of device\n                         //copyUserData(Users, own)\n                         copy.then(final=>{\n                                   console.log('somethingChanged? ',somethingChanged)\n                                   if (somethingChanged) console.log('location data to save', final===own, final)\n\n                                   // save each country without prods to device user IDB\n                                   if (somethingChanged) {\n                                        updateDeviceUserCountries(this.userName, final)   // store everything to deviceUser IDB\n                                        .then(initializeLocationSelects(this, final))      // update screen w new data available\n\n                                   } else return initializeLocationSelects(this, final)\n                                   //final.forEach( country => deviceUserData.countries.put(country) )\n                         })\n\n\n                         /*function copyUserData(users, owndata){\n                              //console.log('EQUAL', ownCountries == owndata)\n                              \n                              return new Promise((resolve, reject)=>{\n                                   const sets = ['countries','cities','shops','products']\n                                   let index = 0\n                                   users.forEach(other_countries => {\n\n                                             // remove products from each country\n                                             const others_cleaned = other_countries.map( country => removeProducts(country,0))     \n\n                                             copyEntries(index, owndata, others_cleaned)\n\n                                             .then(newCountries=> resolve(newCountries) )  \n                                   })\n\n                                   function removeProducts(entry,index){\n                                        //if (index>3) return;\n\n                                        if (entry.hasOwnProperty('products')){\n                                             //console.log('in SHOP', entry.name)\n                                             return {name: entry.name, products: []} //entry.products = []\n\n                                        } else if (entry.name){\n                                             //console.log('|||| not shop', index, entry.name, sets[index])\n                                             let name = entry.name\n                                             let prop = sets[index+1]  // cities shops\n                                             let y \n                                             entry[prop] = entry[prop].map(entry => {\n                                                            //console.log('-- going into',entry.name, sets[index+1])\n                                                            return removeProducts(entry, index+1)\n                                                           })\n                                             //console.log('filtered ',prop,'of',entry.name, entry[prop])\n                                             return entry\n                                        } \n                                   }\n                                   function copyEntries(outerIndex, ownEntries, otherEntries){\n                                        \n                                        function emptyspace(ind){\n                                                  let spaces = \"\", len = ind*5\n                                                  for (let i=0; i<len; i++){\n                                                       spaces = spaces.concat(\" \")\n                                                  }\n                                                  return spaces\n                                        }\n                                        let index = outerIndex +1\n                                        let set = sets[outerIndex], subset = sets[index]\n                                        //console.log(emptyspace(outerIndex),'index', index, set, subset)\n                                        // if its shops now\n\n                                        return new Promise((resolve,rej)=>{\n                                             otherEntries.forEach(other_entry=>{\n                                                  \n                                                  //console.log( emptyspace(outerIndex),`checking others '${other_entry.name}'`)\n\n                                                  if (ownEntries.some(ownEntry=> ownEntry.name == other_entry.name)=== false ) {\n                                                       // not on device -> add it there\n                                                       //console.log(emptyspace(outerIndex),set, 'NOT THERE -> ADDING ',other_entry.name )\n                                                        //console.log(emptyspace(outerIndex),'- doing -', other_entry.name) \n                                                        //let locations = removeProducts( other_entry, index)\n                                                        //console.log('without products',set, locations, subset)\n                                                        //other_entry[subset] = location\n                                                       ownEntries.push(other_entry)\n                                                       somethingChanged = true\n                                                        //console.log(other_entry.name,'updated?',other_entry)\n                                                        //console.log( other_entry.name, 'updated?',locations )\n\n                                                  // if this entry is already there\n                                                  } else{\n                                                       ownEntries.forEach( own_entry=>{\n                                                            //console.log(emptyspace(outerIndex),'checking >>>',subset, 'of',own_entry.name, own_entry)\n                                                            //console.log(emptyspace(outerIndex),set, 'is there checking >>>',own_entry.name, own_entry)\n                                                            // take others subentries and add them to Own\n                                                            if (own_entry.name === other_entry.name){\n                                                                 //console.log(emptyspace(outerIndex),`duplicates ${own_entry.name} = ${other_entry.name}`)\n                                                                 //console.log(emptyspace(outerIndex),index, 'subset',subset,'<<')\n                                                                 if (index<3)//subset!==undefined) // if subset is undefined, can it even reach this deep? i.e. - if the condition neccessary\n                                                                 copyEntries(index, own_entry[subset], other_entry[subset] )\n\n                                                                 else if (subset===undefined) {\n                                                                      \n                                                                      //console.log(emptyspace(outerIndex),'??',own_entry)\n                                                                      //let smt = removeProducts(own_entry,index)\n                                                                      //console.log(emptyspace(outerIndex),'done ------- with', set)\n                                                                 }\n                                                            } //it gets added above\n                                                       })\n                                                  }\n                                             })\n                                             resolve(ownEntries)\n                                        })\n                                   }\n                              })\n                         }*/\n                    }\n               })\n\n               // this must stay\n               .catch( er => {\n                    \n                    if (er===null && !this.userName){\n                         //console.log('- - - will initialize Country data')\n                         \n                         storeInitialDBData(this.userName)\n                         .then( data =>{\n                              console.log('- - - stored?', data)\n                              initializeLocationSelects(this, initalCountryData)\n                              //this.reloadView()\n                         })\n                    } else if (er === null && this.userName) {\n                         console.log(`- - - will autofetch MDB data of ${this.userName}`)\n                         // autofetch users MDB data and restart app\n                         this.fetchMyCountries()\n\n                    } else \n                         console.error('!!!!!  there was real error\\n error getting init data',er)\n               })\n          \n\n          }\n     },\n     mounted: function(){\n          //window.initializeLocationSelects = initializeLocationSelects.bind(this)\n          \n          this.startApp()\n\n          checkDrBxToken()\n     },\n     created:function(){\n          //console.log('CREATED')\n     }\n})\n\n\n\nfunction errorHandler(er){\n     stopLoaderAnimation.call(this)\n     console.error(er)\n     return this.informUser(`error occured, please try again later`)\n}\n\n\n\n\nconst findImgNamesNotInIDB = arrays => \n     new Promise((resolve, reject)=>{\n\n          const flatArray = []     // all images that will be used in others countries\n          arrays.forEach(array=>{ if (array) flatArray.push(...array) })\n          console.log('  -- flatArray', flatArray)\n\n          picturesDB.item.toArray()\n          .then(allImgs => {\n     \n               //console.log('array result?', allImgs)\n\n               //find images that arent present on device\n               const imgsToBeFetched = flatArray.filter(img=> allImgs.some(idbImg=>img.imgName===idbImg.fileName)==false)\n\n               console.log('  -- imgsToBeFetched', imgsToBeFetched)\n               resolve(imgsToBeFetched)\n          })\n})\n\nconst loadProductIDBURLs = async (countries) =>{\n          //let result;\n          const pures = [], proms = []\n\n          countries.forEach((country, cI)=>\n               country.cities.forEach((city,ciI)=>\n                    city.shops.forEach((shop,sI)=>\n                         shop.products.forEach((prod,pI)=>{\n                              if (prod.imgName) {\n                                   //prod.displayURL = getSingleIDBimg(prod)\n                                   pures.push(prod)\n                                   proms.push( getSingleIDBimg(prod) )\n                              }\n                              /*if (cI == countries.length-1 && \n                                  ciI== country.cities.length-1 && \n                                  sI == city.shops.length-1 && \n                                  pI == shop.products.length-1) {\n                                       //console.log('|||||  doing last item!', country.name, prod.name)\n                                       //resolve(countries)\n                                       //result = countries\n                                   }*/\n                         })\n                    )\n               )\n          )\n          const urls = await Promise.all(proms)\n\n          pures.forEach((prod,i) => prod.displayURL = urls[i])\n          //console.log('this happens last', countries)\n          return countries\n}\n\nconst getSingleIDBimg = prod => new Promise((resolve, reject)=>{\n          \n          picturesDB.item.get({fileName:prod.imgName})\n          .then(result => {\n                    //console.log('img idb result?', result.data.substr(0, 50))\n                    //console.log('img idb result?',result)\n                    if (result) resolve(result.data)\n                    else resolve (null)\n          })\n          .catch(er=>{ \n                    console.error('error getting IDB img data', er)\n                    resolve(null) \n          })\n})     \n\nconst getListOfImgNamesAndURLs = countries =>\n\n     new Promise((resolve, reject)=>{\n          //getOwnIDBData(this.userName)     \n          //.then( countries =>{\n               const urls = []\n               countries.forEach(country=>\n                    country.cities.forEach(city=>\n                         city.shops.forEach(shop=>\n                              shop.products.forEach(prod=>{\n                                   if (prod.dbxURL) urls.push({ imgName: prod.imgName, url: prod.dbxURL})\n                              })\n                         )\n                    )\n               )\n               console.log('urls found in countries', urls)\n               if (urls.length>0) resolve(urls)\n               else resolve(null)\n          //})\n})\n     \n\n\n\n\nconst fetchDbxImage = url =>\n     new Promise((resolve, reject)=>{\n\n          //let d2    = 'https://dl.dropboxusercontent.com/s/jl15lcir35926i5/okram%40protonmail.ch_D2018-01-12_T22-09-07.jpg' \n          //let dbximg= 'https://www.dropbox.com/s/jl15lcir35926i5/okram%40protonmail.ch_D2018-01-12_T22-09-07.jpg'\n          //  https://www.dropboxforum.com/t5/API-support/CORS-issue-when-trying-to-download-shared-file/td-p/82466/page/2\n          \n\n          const req1 = new Request(url,{\n               headers: new Headers({\n                    //'Content-Type': 'image/png'\n               }),\n               method: 'GET'\n          })\n          var image = new Image(); //image.crossOrigin = \"Anonymous\"\n\n          fetch(req1)\n          .then(result=>{\n               console.log('img result',result)\n               return  result.blob()//result.arrayBuffer()\n               \n               \n          }).then(blob=>{\n               //console.log('res', blob)\n               let r = new FileReader()\n\n               r.onloadend = function(ev){\n                    resolve(ev.target.result)\n               }\n               r.onerror = function(er){\n                    console.error('reader error - reading image', er)\n                    resolve(null)\n               }\n               r.readAsDataURL(blob)\n               \n               //const URL = window.URL || window.webkitURL;\n               //image.src = URL.createObjectURL(blob);\n          })\n          .catch(er=>{\n               console.error('ERROR fetching dbx image data', er)\n               resolve(null)\n               //reject(er)\n          })\n          \n          /*let xhr = new XMLHttpRequest()\n               if (\"withCredentials\" in xhr) { console.log('with creds') }\n               xhr.onreadystatechange = function(){\n                    if (this.readyState == 4 && this.status == 200) {\n                         console.log(this.response, this.responseText, this.responseType)\n\n                    } else console.log(this.status, this.response)\n               }\n               xhr.open('GET', CE + 'https://www.dropbox.com/s/jl15lcir35926i5/okram%40protonmail.ch_D2018-01-12_T22-09-07.jpg?dl=0', true)\n               console.log(xhr)\n               xhr.send()*/\n})\n\n\nconst deleteDropboxImg = (email, fileName)=>{\n\n     return new Promise((resolve, reject)=>{\n          if (!email || ! fileName) reject(null)\n\n          const xhr = new XMLHttpRequest()\n          xhr.onreadystatechange = function(){\n               if (this.readyState == 4 && this.status == 200) {\n\n                    console.log('SUKCES deleting dbx image', this.response, this.responseText)\n                    resolve(this.response)\n\n               } else console.log('so?', this.status, this.responseText) //this.getAllResponseHeaders())\n          }\n          xhr.open('POST', serverURL + '/API/deleteDrbxImage' + `?email=${email}&fileName=${fileName}` , true)\n          xhr.send()\n     })\n}\n\n\n// set image property so its accessible publicly any time it ll be needed by others\nconst uploadImgToDropbox = function(newName='test', imgData, file, blobb){\n     return new Promise((resolve, reject)=>{\n\n          let fileName = newName// + new Date()\n          //console.log(this.userName,'fileName', fileName, file, blobb)\n\n          const email = localStorage.getItem('deviceUserEmail')\n          const toSend = { email }//data: JSON.stringify(imgData)\n          \n          // https://stackoverflow.com/questions/9395911/send-a-file-as-multipart-through-xmlhttprequest\n          // https://stackoverflow.com/questions/15001822/sending-large-image-data-over-http-in-node-js\n          // https://stackoverflow.com/questions/5052165/streaming-an-octet-stream-from-request-to-s3-with-knox-on-node-js\n          // https://stackoverflow.com/questions/3146483/html5-file-api-read-as-text-and-binary\n          /*let fd = new FormData()\n               fd.append('json', JSON.stringify(toSend))\n               fd.append('imgData', imgData )  // stringify imgData didnt work\n               //fd.append('blob', new Blob([ file ] ))\n               fd.append('ffile',  file  )\n               fd.append('blobb', blobb )\n          */\n          /*fetch(serverURL + '/API/postPicToDrbx' + '?' + 'name='+ this.userName,{\n               method: 'POST',\n               body: imgData\n               })*/\n\n               /*fd.append('json_data', JSON.stringify({a: 1, b: 2}))\n               fd.append('binary_data', new Blob([binary.buffer])\n          */\n\n          const xhr = new XMLHttpRequest()\n          xhr.onreadystatechange = function(){\n               if (this.readyState == 4 && this.status == 200) {\n\n                    console.log('SUKCES uploading to dbx -link?', this.response)//, this.responseText)\n                    //resolve(this.status)\n                    resolve(this.response)\n\n               } else console.log('so?', this.status, this.responseText) //this.getAllResponseHeaders())\n          }\n          xhr.open('POST', serverURL + '/API/postPicToDrbx' + `?email=${email}&fileName=${fileName}` , true)\n          xhr.send(imgData)\n          // \n          //\n          //xhr.send(fd) // imgData\n          \n               /*let params = {\n                    \"path\": fileName,\n                    \"mode\": \"add\"\n               }  // \"autorename\": true, \"mute\": false\n               params = JSON.stringify(params)  \n\n               let bearer = \"Bearer \" + window.accessToken\n               bearer = JSON.stringify(bearer)\n               console.log('bearer', bearer)\n               \n               xhr.open('POST','https://content.dropboxapi.com/2/files/upload', true)\n               xhr.setRequestHeader(\"Authorization\", bearer)\n               xhr.setRequestHeader(\"Dropbox-API-Arg\", params)\n               xhr.setRequestHeader('Content_Type','application/octet-stream')\n\n               //xhr.setRequestHeader(\"Authorization\", \"Bearer qAZQ0ocdGioAAAAAAAACt4axxwChUOZ5U2XLXB1hvSzxXai4btwbq7O3LjzMst5c\")\n               //xhr.setRequestHeader(\"Dropbox-API-Arg\", obj)\n               //xhr.responseType = 'blob';\n               //xhr.send()\n               \n               \n          xhr.send(imgData)*/\n          // later set images to be accessible from dropbox publicly?\n     })\n}\n\n\nfunction getImgIDBDataOf(names){\n\n     //console.log('getting img data', names)\n\n     const promises = names.map(name=>\n          new Promise((resolve, reject)=>\n               \n               picturesDB.item.get({fileName:name})\n\n               .then(result=>{ resolve(result.data) })\n               .catch(er=>{ resolve(null) })\n\n          )\n     )\n     return Promise.all(promises)\n}\n\nfunction saveImageToIDB(fileName, data, userName = 0){\n     //console.log(getDeviceUser(), fileName)\n     if (!userName) return alert('proived userName to function')\n\n     return new Promise((resolve, reject)=>{\n          if (!fileName || !data || !userName) reject(null)\n\n          picturesDB.item.put({ 'fileName': fileName, 'userName': userName, 'data': data })\n          .then(result=>{\n               console.log('saved img to IDB ->',result)\n               resolve(result)\n          })\n          .catch(er=>{\n               console.error('Error saving image raw data to IDB',er)\n          })\n     })\n}\n\n// deleteImageFromIDB(\"auntie@auntie.at_D2018-01-27_T14-19-45\")\nfunction deleteImageFromIDB(fileName){\n     //console.log(fileName, picturesDB.item)\n     return new Promise((resolve, reject)=>{\n          \n\n          picturesDB.item.where('fileName').equals(fileName).delete()\n          .then(something=>{\n\n               console.log('deleted?',something)\n               resolve(something)\n          })\n          .catch(er=>console.error(er))        \n     })\n\n}\n\nconst getPicURL = function(entry){\n\n     return new Promise((resolve, reject)=>{\n\n          let obj = {\"path\": entry.path_display }\n          obj = JSON.stringify( entry) \n          const xhr = new XMLHttpRequest()\n          xhr.onreadystatechange = function(){\n\n               if (this.readyState == 4 && this.status == 200) {\n\n                         console.log('SUKCES', this.status)//this.response, this.responseText)\n                         resolve(this.responseText)\n\n               } else console.log(this.status)\n          }\n          xhr.open('POST', serverURL + '/API/getPicURL', true)\n          xhr.send(obj)\n     })\n}\n\n\n\n\n\nfunction fetchDataOfFollowedUsers(){\n\n     return new Promise((resolve, reject)=>{\n\n     \n     const fetchedCountryData = this.followedUsers.map(fetchCountriesOfUser) // get new data for each followed user\n\n     Promise.all(fetchedCountryData)\n     .then(userData=>{   // store new user data\n\n          console.log('nav online - fetched', fetchedCountryData)\n          const saved = userData.map(user=>setOtherUserIDBData(user))\n                              \n          return Promise.all(saved)\n     }).then(saved=>{      // reloadView() is where new locations get copied to users countries\n\n          console.log('starting app - other users data', saved)\n          //stopLoaderAnimation.call(this)\n          //return this.reloadView()\n          resolve('test')\n\n     }).catch(er=>console.error('error in online branch',er))\n\n     })\n}\n\n\nconst findProductLocations = (countries, imgName)=>{\n\n     if (!imgName || imgName=='') return console.error('provide imgName')\n\n     let countryName, cityName, shopName, shop, product, i\n\n     countries.forEach(cntry=>\n          cntry.cities.forEach(cty=>\n               cty.shops.forEach(shp=>\n                    shp.products.forEach((prod,index)=>{\n                              if (prod.imgName && prod.imgName === imgName){\n\n                                        countryName = cntry.name\n                                        cityName = cty.name\n                                        shopName = shp.name\n                                        shop = shp\n                                        product = prod\n                                        i = index\n                              }\n                    })\n               )\n          )\n     )\n\n     return {countryName, cityName, shopName, shop, product, i}\n}\n\nconst addOwner = (countries, nameToAdd) =>{\n\n     countries.forEach(country=>\n          country.cities.forEach(city=>\n               city.shops.forEach(shop=>\n                    shop.products.forEach(prod=>\n                         prod.owner = nameToAdd\n                    )\n               )\n          )\n     )\n     return countries\n}\n\nconst copyUserDataOrig = (users, owndata, removeProds) => {\n                              \n          let somethingChanged = 0\n          const sets = ['countries','cities','shops','products']\n          let index = 0\n\n          //console.log('removeProds?', removeProds)\n\n\n          users.forEach(other_countries => {\n     \n                    let others_cleaned\n                    if (removeProds) {\n                         //console.log('removing prods')\n                         others_cleaned = other_countries.map( country => removeProducts(country,0))\n                    } else {\n                         //console.log('keeping products')\n                         others_cleaned = other_countries\n                    }\n\n\n                    copyEntries(index, owndata, others_cleaned)\n          })\n          \n          \n          return({ somethingChanged, countries: owndata})\n\n\n          function copyEntries(outerIndex, ownEntries, otherEntries){\n               \n               let index = outerIndex +1\n               let set = sets[outerIndex], subset = sets[index]\n\n               otherEntries.forEach(other_entry=>{\n                         //console.log( emptyspace(outerIndex),`checking others '${other_entry.name}'`)\n\n                         if (ownEntries.some(ownEntry=> ownEntry.name == other_entry.name)=== false ){\n                         // it's not on device -> add it there\n                              console.log(emptyspace(outerIndex),set, 'NOT THERE -> ADDING ',other_entry.name )\n                              \n                              ownEntries.push(other_entry)\n                              somethingChanged = true\n                              \n\n                         // this entry is already there\n                         } else ownEntries.forEach( own_entry=>{\n                              //console.log(emptyspace(outerIndex),'checking >>>',subset, 'of',own_entry.name, own_entry)\n                              //console.log(emptyspace(outerIndex),set, 'is there checking >>>',own_entry.name, own_entry)\n                              // take others subentries and add them to Own\n                              if (own_entry.name === other_entry.name){\n                                   //console.log(emptyspace(outerIndex),`duplicates ${own_entry.name} = ${other_entry.name}`)\n                                   //console.log(emptyspace(outerIndex),index, 'subset',subset,'<<')\n\n                                        if (index< 3)  copyEntries( index, own_entry[subset], other_entry[subset] )\n\n                                        else if (index===3 && !removeProds)\n                                             copyEntries(index, own_entry[subset], other_entry[subset] )\n                                   \n\n                              } //it gets added above\n                         })\n                         \n                         \n               })\n               return ownEntries\n               \n          }\n          function removeProducts(entry,index){\n               //if (index>3) return;\n\n               if (entry.hasOwnProperty('products')){\n                    //console.log('in SHOP', entry.name)\n                    return {name: entry.name, products: []} //entry.products = []\n\n               } else if (entry.name){\n                    //console.log('|||| not shop', index, entry.name, sets[index])\n                    let name = entry.name\n                    let prop = sets[index+1]  // cities shops\n                    let y \n                    entry[prop] = entry[prop].map(entry => {\n                                   //console.log('-- going into',entry.name, sets[index+1])\n                                   return removeProducts(entry, index+1)\n                              })\n                    //console.log('filtered ',prop,'of',entry.name, entry[prop])\n                    return entry\n               } \n          }\n          function emptyspace(ind){\n               let spaces = \"\", len = ind*5\n               for (let i=0; i<len; i++){\n                    spaces = spaces.concat(\" \")\n               }\n               return spaces\n          }\n     \n}\n\nfunction addNewLocationToDB(set, toAdd){\n     console.log('adding', set, this.userName)\n     //return console.log('this', this)\n     getOwnIDBData(this.userName)\n     .then( ownCountries =>{\n          if (set!=='product') toAdd = toAdd.toString()\n\n          let somethingChanged = '333' //false\n          const copyData = new Function('users', 'owndata', copyUserData_text)\n          const self = this\n          \n          let toSave, lastLocs = []\n\n          if (set =='country'){\n                         \n                         //let index = this.countries.findIndex(country=>country.name == toAdd)\n                         let index = ownCountries.findIndex(country=>country.name == toAdd)\n\n                         if (index>-1) { return self.informUser(`'${toAdd}' is already in your database`) }\n\n                         const newCountry = \n                                   [{   name: toAdd, \n                                        cities: [{\n                                             name: 'all cities', \n                                             shops:[{\n                                                  name: 'all shops',\n                                                  products: []\n                                             }]\n                                        }]\n                                   }]\n                         \n                         toSave = [newCountry]\n                         lastLocs.push({key: 'countries', value: toAdd})\n                         lastLocs.push({key: 'cities', value: 'all cities'})\n                         lastLocs.push({key: 'shops',  value: 'all shops'})\n\n          } else if (set =='city') { console.log(`this happens 1`)\n\n                    //let countryData = this.countries.find(cntry=> cntry.name == this.currentCountry)\n                    let countryData = ownCountries.find(cntry=> cntry.name == this.currentCountry)\n                    \n                    // check if this city is already there\n                    let index = countryData.cities.findIndex(city=>city.name == toAdd)\n\n                    if (index>-1){ return alert(`'${toAdd}' is already in your database`) }\n                    \n\n                    countryData.cities.push({\n                                        name: toAdd, \n                                        shops:[{\n                                             name: 'all shops',\n                                             products: []\n                                        }]\n                    })\n                    console.log( '   adding city',\"\\n\",countryData)\n                    console.log( '   original',\"\\n\",ownCountries)\n\n                    toSave = [[countryData]]\n\n                    lastLocs.push({key: 'cities', value: toAdd})\n                    lastLocs.push({key: 'shops', value: 'all shops'})\n\n          } else if (set =='shop') {  console.log(`this happens 1`)\n\n               //let countryData = this.countries.find(cntry=> cntry.name ===this.currentCountry)\n               let countryData = ownCountries.find(cntry=> cntry.name ===this.currentCountry)\n               \n               let cityData = countryData.cities.find(city=> city.name === this.currentCity)\n               console.log( '   adding shop ', toAdd, 'to', cityData.name)\n\n               // check its not there already\n               if (cityData.shops.findIndex(shop=>shop.name===toAdd) > -1)\n                         return alert(`'${toAdd}' is already in your database`)\n               \n\n               cityData.shops.push(\n                                        {\n                                        name: toAdd,\n                                        products: []\n                                        }\n                                   )\n\n               console.log('   new entry now', this.currentCountry, countryData)\n               \n               toSave = [[countryData]]\n               lastLocs.push({key:'shops', value: toAdd})\n               \n          } else if (set=='product'){\n               //let countryData = this.countries.find(cntry=> cntry.name=== this.currentCountry)\n               let countryData = ownCountries.find(cntry=> cntry.name=== this.currentCountry)\n               let cityData = countryData.cities.find(city=> city.name === this.currentCity)\n               let shopData = cityData.shops.find(shop=> shop.name=== this.currentShop)\n\n               shopData.products.push(toAdd)\n               console.log('shopData', shopData)\n               console.log('countryData', countryData)\n               toSave = [[countryData]]\n          }\n          \n          // \n\n          //copyData( toSave, [...this.countries] )\n          copyData( toSave, [...ownCountries] )\n          .then(final=>{\n                    console.log('location data to save', final===this.countries, final)\n\n\n                    lastLocs.forEach(item=>setLastSelection(item.key, item.value))\n\n                    return updateDeviceUserCountries(this.userName, final)\n                              \n          }).then(result=>{\n                    console.log('result', result)\n                    return initializeLocationSelects(this, result)\n          })\n          .catch(er=>{\n               alert('add Loc to DB er' + er)\n          })\n\n\n          return this.switchScreen('main')\n     })\n}\n\nconst sendCountryDataOfUser = userObj =>\n\n     new Promise((resolve, reject)=>{\n\n          getOwnIDBData(userObj.userName)\n          .then(countries=>{\n               console.log(`data of - ${userObj.userName} - to be pushed to MDB`, countries)\n\n               const request = new Request(serverURL + 'API/pushCountriesOfUser',{\n                    headers: new Headers({\n                         'Content-Type': 'application/json'\n                    }),\n                    method: 'POST',\n                    mode:'no-cors',\n                    body: JSON.stringify({\n                         email: userObj.email,\n                         countries\n                    })\n               })\n     \n\n               fetch(request).then(result =>{\n                    console.log('result ',result)\n                    resolve(null)\n               })\n\n\n          }).catch(er=>{\n               console.error(er)\n               reject(er)\n          })\n     })\n\n\n\nfunction fetchCountriesOfUser(user){\n\n     return new Promise((resolve, reject)=>{\n          console.log(`geeting data of ${user.email}`)\n\n          const xhr = new XMLHttpRequest()\n          xhr.onreadystatechange = function(){\n               if (this.readyState == 4 && this.status == 200) {     // console.log(this.status,'received',typeof this.responseText)\n\n                         const result = JSON.parse(this.responseText)\n                         result.userName = user.userName\n\n                         //console.log('   got user data from server',result.email, result)\n                         resolve(result)\n\n               } else if (this.readyState == 4 && this.status!=200) reject()\n          }\n          xhr.open('POST',serverURL + 'API/getCountriesOfUser',true)\n          xhr.send(user.email)\n     })\n}\n\nfunction setOtherUserIDBData(allData){\n     console.log('allData to put to IDB >', allData)\n     return new Promise((resolve, reject)=>{\n\n          users_followed.userData.put(allData)\n          .then(result=>{\n               //console.log(result)  // this returns primary key i.e. email\n               resolve()\n          }).catch(er=>{\n               console.error(er)\n               reject()\n          })\n     })\n}\n\n\nfunction setLastSelection(set, value){\n     //console.log('>> saving', set, value)\n     window.localStorage.setItem(set, value.toString() )\n}\nfunction getLastSelection(set){\n     \n     let val = window.localStorage.getItem(set)\n     //console.log('requested', set, val)\n     return val\n}\n\n\n\nfunction getLSfollowedUsers(){\n     let users = window.localStorage.getItem('followedUsers')\n     users = JSON.parse(users)\n     return users\n}\nfunction addUserNameToFollowed(newUser){\n\n     let users = window.localStorage.getItem('followedUsers')\n     users = JSON.parse(users)\n\n     if (users===null) users = [newUser]\n     else if (users.some(user=>user.email==newUser.email)===false) users.push(newUser) // add new user only if he isnt there yet\n\n     console.log('LS users now', users)\n\n     return window.localStorage.setItem('followedUsers', JSON.stringify(users))\n}\n\n\nfunction updateDeviceUser(name = 0){\n     //if ( window.localStorage.getItem('deviceUser') === null){\n          name = name.toString().trim()\n\n          const initialData = {\n               userName: name, \n               createdDate: getFormattedDate(null)\n          } \n          window.localStorage.setItem('deviceUser', JSON.stringify(initialData)) \n     //}\n     console.log('created user', window.localStorage.getItem('deviceUser') )\n}\n\nfunction getDeviceUser(){\n\n          let data = JSON.parse(window.localStorage.getItem('deviceUser'))\n          if (data) return data.userName\n          else return undefined\n}\n\nfunction getOwnIDBData(user = 0){\n     console.log(`getting IDB country data of ${user}`)\n\n     return new Promise((resolve, reject)=>{\n\n          //console.log('test1',deviceUserData.userData.userName)\n\n          /*if (deviceUserData.userData===undefined) {\n               console.log('!! 1st condition')\n               return reject(null)\n          }*/\n          //console.log('test test', window.indexedDB)//deviceUserData.userData)\n\n          //.toArray()   // https://dexie.org/docs/Table/Table.get()\n          return deviceUserData.userData.get({\"userName\":user})\n          .then(data => {\n               //alert('test test 22')\n               console.log('device user data',data)\n\n               if (data==undefined) {\n                    console.log('no data, probably initializing app?')\n                    return reject(null) // used now to store intitial country data\n               } \n\n               const res = data.countries\n               \n               if (Array.isArray(res)) resolve(res)\n\n               else if (res.hasOwnProperty('name')){\n                    console.log('got only initial data')\n                    resolve([res])\n               }\n          })\n          .catch(er => {\n               console.log('||||||||||  error',er)\n               reject(er) \n          })\n     })\n}\n\nfunction storeInitialDBData(userName = 0){\n     console.log(`storing data for ${userName}`)\n     return new Promise((resolve, reject)=>{\n          //console.log(window.deviceUserData.userData)\n          \n          deviceUserData.userData.put({userName, countries: initalCountryData})\n\n          .then(all=>{\n                    console.log('stored initial data:', all,\"<<\")\n                    resolve(all)\n          })                         \n          .catch(er=>{\n               console.error(er);\n               reject(er)\n          })\n     })\n}\n\nfunction getOtherUsersIDBData(localUsers){\n     //console.log('    localUsers', localUsers)\n\n     return new Promise((resolve,rej)=>{\n          if (!localUsers || localUsers.length==0) return resolve(null)\n\n          users_followed.userData.toArray()\n          .then(users =>{ \n               \n               users = users.filter(user=> localUsers.find(lUser=>lUser.email==user.email)!==undefined )\n               console.log('|||     filtered users',users)\n\n               if (users.length==0) resolve(null)     // when can this happen?\n               else resolve(users)\n\n          })\n          .catch(er=>console.error('error opening following', er))\n     })\n}\n\n\nfunction initializeLocationSelects(self, countries){\n     console.log('initializing countries\\n')\n\n     self.countries = countries\n     self.currentCountry = getLastSelection('countries') || 'all countries'\n     \n     \n     let lastCntry = countries.find(cn=>cn.name=== self.currentCountry)\n     self.cities = lastCntry.cities\n\n     // city\n     self.currentCity = getLastSelection('cities') || 'all cities' \n     let lastCity = self.cities.find(city => city.name ==  self.currentCity)\n\n     // shop\n     self.shops = lastCity.shops\n     self.currentShop =  getLastSelection('shops')  || 'all shops'\n\n\n     // 2 stands for 'shop/s' in array, null for event, currentShop = requested shop name\n     //let somevar = self.updateLocationSelect(2, null, self.currentShop)\n\n}\n\n\n\nfunction copyUserData(users, owndata){\n     console.log('EQUAL', users, owndata)\n     //console.log('copying', somethingChanged)//users, owndata)\n     \n     return new Promise((resolve, reject)=>{\n          const sets = ['countries','cities','shops','products']\n          let index = 0\n          users.forEach(other_countries => {\n\n                    // remove products from each country\n                    const others_cleaned = other_countries.map( country => removeProducts(country,0))     \n\n                    copyEntries(index, owndata, others_cleaned)\n\n                    .then(newCountries=> resolve(newCountries) )  \n          })\n\n          function removeProducts(entry,index){\n               //if (index>3) return;\n\n               if (entry.hasOwnProperty('products')){\n                    //console.log('in SHOP', entry.name)\n                    return {name: entry.name, products: []} //entry.products = []\n\n               } else if (entry.name){\n                    //console.log('|||| not shop', index, entry.name, sets[index])\n                    let name = entry.name\n                    let prop = sets[index+1]  // cities shops\n                    let y \n                    entry[prop] = entry[prop].map(entry => {\n                                   //console.log('-- going into',entry.name, sets[index+1])\n                                   return removeProducts(entry, index+1)\n                                  })\n                    //console.log('filtered ',prop,'of',entry.name, entry[prop])\n                    return entry\n               } \n          }\n          function copyEntries(outerIndex, ownEntries, otherEntries){\n               \n               function emptyspace(ind){\n                         let spaces = \"\", len = ind*5\n                         for (let i=0; i<len; i++){\n                              spaces = spaces.concat(\" \")\n                         }\n                         return spaces\n               }\n               let index = outerIndex +1\n               let set = sets[outerIndex], subset = sets[index]\n               //console.log(emptyspace(outerIndex),'index', index, set, subset)\n               // if its shops now\n\n               return new Promise((resolve,rej)=>{\n                    otherEntries.forEach(other_entry=>{\n                         \n                         //console.log( emptyspace(outerIndex),`checking others '${other_entry.name}'`)\n\n                         if (ownEntries.some(ownEntry=> ownEntry.name == other_entry.name)=== false ) {\n                              // not on device -> add it there\n                              //console.log(emptyspace(outerIndex),set, 'NOT THERE -> ADDING ',other_entry.name )\n                               //console.log(emptyspace(outerIndex),'- doing -', other_entry.name) \n                               //let locations = removeProducts( other_entry, index)\n                               //console.log('without products',set, locations, subset)\n                               //other_entry[subset] = location\n                              ownEntries.push(other_entry)\n                              somethingChanged = true\n                               //console.log(other_entry.name,'updated?',other_entry)\n                               //console.log( other_entry.name, 'updated?',locations )\n\n                         // if this entry is already there\n                         } else{\n                              ownEntries.forEach( own_entry=>{\n                                   //console.log(emptyspace(outerIndex),'checking >>>',subset, 'of',own_entry.name, own_entry)\n                                   //console.log(emptyspace(outerIndex),set, 'is there checking >>>',own_entry.name, own_entry)\n                                   // take others subentries and add them to Own\n                                   if (own_entry.name === other_entry.name){\n                                        //console.log(emptyspace(outerIndex),`duplicates ${own_entry.name} = ${other_entry.name}`)\n                                        //console.log(emptyspace(outerIndex),index, 'subset',subset,'<<')\n                                        if (index<3)//subset!==undefined) // if subset is undefined, can it even reach this deep? i.e. - if the condition neccessary\n                                        copyEntries(index, own_entry[subset], other_entry[subset] )\n\n                                        else if (subset===undefined) {\n                                             \n                                             //console.log(emptyspace(outerIndex),'??',own_entry)\n                                             //let smt = removeProducts(own_entry,index)\n                                             //console.log(emptyspace(outerIndex),'done ------- with', set)\n                                        }\n                                   } //it gets added above\n                              })\n                         }\n                    })\n                    resolve(ownEntries)\n               })\n          }\n     })\n}\n\n\nfunction updateDeviceUserCountries(userName=0, countries){\n     console.log(`save to user: ${userName} ${countries}`)\n     let obj = { userName, countries }\n     //console.log(obj)\n     return new Promise((resolve, reject)=>{\n\n          deviceUserData.userData.put({ userName, countries })\n          .then(result=>{\n               console.log(result)\n               resolve(countries)\n\n          }).catch(er=>{})\n     })\n}\nconst copyUserData_text = `\n     console.log('newdata, owndata', users, owndata)\n     //console.log('copying', somethingChanged)//users, owndata)\n\n     return new Promise((resolve, reject)=>{\n          const sets = ['countries','cities','shops','products']\n          let index = 0\n          users.forEach(other_countries => {\n                    console.log(other_countries)\n                    // remove products from each country  \n                    // not if its used to store new location\n                    //const others_cleaned = other_countries//.map( country => removeProducts(country,0))     \n\n                    copyEntries(index, owndata, other_countries)//others_cleaned)\n\n                    .then(newCountries=> resolve(newCountries) )  \n          })\n\n          function removeProducts(entry,index){\n               //if (index>3) return;\n\n               if (entry.hasOwnProperty('products')){\n                    //console.log('in SHOP', entry.name)\n                    return {name: entry.name, products: []} //entry.products = []\n\n               } else if (entry.name){\n                    //console.log('|||| not shop', index, entry.name, sets[index])\n                    let name = entry.name\n                    let prop = sets[index+1]  // cities shops\n                    let y \n                    entry[prop] = entry[prop].map(entry => {\n                                   //console.log('-- going into',entry.name, sets[index+1])\n                                   return removeProducts(entry, index+1)\n                              })\n                    //console.log('filtered ',prop,'of',entry.name, entry[prop])\n                    return entry\n               } \n          }\n          function copyEntries(outerIndex, ownEntries, otherEntries){\n               \n               function emptyspace(ind){\n                         let spaces = \"\", len = ind*5\n                         for (let i=0; i<len; i++){\n                              spaces = spaces.concat(\" \")\n                         }\n                         return spaces\n               }\n               let index = outerIndex +1\n               let set = sets[outerIndex], subset = sets[index]\n               //console.log(emptyspace(outerIndex),'index', index, set, subset)\n               // if its shops now\n\n               return new Promise((resolve,rej)=>{\n                    otherEntries.forEach(other_entry=>{\n                         \n                         if (ownEntries.some(ownEntry=> ownEntry.name == other_entry.name)=== false ) {\n                              // not on device -> add it there\n                              console.log(emptyspace(outerIndex),set, 'NOT THERE -> ADDING ',other_entry.name )\n                              //console.log(emptyspace(outerIndex),'- doing -', other_entry.name) \n                              //let locations = removeProducts( other_entry, index)\n                              //console.log('without products',set, locations, subset)\n                              //other_entry[subset] = location\n                              ownEntries.push(other_entry)\n                              //console.log(somethingChanged)\n                              //if (somethingChanged!=undefined) somethingChanged = true\n                              //console.log(other_entry.name,'updated?',other_entry)\n                              //console.log( other_entry.name, 'updated?',locations )\n\n                         // if this entry is already there\n                         } else{\n                              ownEntries.forEach( own_entry=>{\n                                   //console.log(emptyspace(outerIndex),'checking >>>',subset, 'of',own_entry.name, own_entry)\n                                   //console.log(emptyspace(outerIndex),set, 'is there checking >>>',own_entry.name, own_entry)\n                                   // take others subentries and add them to Own\n                                   if (own_entry.name === other_entry.name){\n                                        //console.log(emptyspace(outerIndex),index, 'subset',subset,'<<')\n                                        if (index<3)//subset!==undefined) // if subset is undefined, can it even reach this deep? i.e. - if the condition neccessary\n                                        copyEntries(index, own_entry[subset], other_entry[subset] )\n\n                                        else if (subset===undefined) {\n                                             \n                                             //console.log(emptyspace(outerIndex),'??',own_entry)\n                                             //let smt = removeProducts(own_entry,index)\n                                             //console.log(emptyspace(outerIndex),'done ------- with', set)\n                                        }\n                                   } //it gets added above\n                              })\n                         }\n                    })\n                    resolve(ownEntries)\n               })\n          }\n     })`\n//\n\n\nfunction updateDBXToken (email, token){\n     return new Promise((resolve, reject)=>{\n          console.log('tokenizing', email, token)\n\n          const request = new Request(serverURL + 'API/updateDBXToken',{\n               headers: new Headers({\n                    'Content-Type': 'application/json'\n               }),\n               method: 'POST',\n               mode:'no-cors',\n               body: JSON.stringify({ email, token })\n          })\n     \n     \n          fetch(request)\n          .then(response=>resolve(response))\n     })\n}\nfunction checkDrBxToken (){\n\n     const user = localStorage.getItem('deviceUserEmail')\n     if (!user) return; //alert('token? no user')\n\n     if ( navigator.onLine && window.location.hash && \n          window.location.hash.includes('access_token=') && \n          window.location.hash.includes('token_type=bearer')){\n          \n          animateLoader.call(app)\n\n          // #access_token=aL0Dh78132HV...\n          // &token_type=bearer  // &uid=302342838  // &account_id=dbid%3CCCB5NUHLEil2GAOA3Si3wQmQ2pBC6qKCsEo  // some fake credentials\n\n          let str = window.location.hash.substr(1)\n          let arr = decodeURI(str).split('&')\n          //console.log(str,'arr',arr)\n          const token = arr[0].replace('access_token=','')\n\n          // save token to MDB and reload window to prevent accidental reupdates if leaving token in address bar\n          updateDBXToken(user, token)\n          .then(resp => window.location.href = window.location.origin )\n          \n          \n     } else { console.log('####   no new dropbox token   ####')\n     }//\n}\n/*let getDropToken = function(){\n     const xhr = new XMLHttpRequest()\n     xhr.onreadystatechange = function(){\n                    if (this.readyState == 4 && this.status == 200) {\n                         console.log('SUKCES', this.response, this.responseText)\n                    } else console.log('header',this.status, this.getAllResponseHeaders())\n     }\n          //let url = 'https://www.dropbox.com/oauth2/authorize?' + 'response_type=token&' + 'client_id=111111hwhqd69ima3zv29t&' + 'redirect_uri=http://localhost:1234/'\n     let url = 'https://api.dropboxapi.com/oauth2/token'\n     xhr.open('POST',url, true)\n     //xhr.send(   )\n     }\nconst getfileThumb = function(fileEntry){\n          \n          const id = fileEntry.id\n\n          //let obj = { \"path\": id , format: \"jpeg\", size: \"w128h128\" }\n          let obj = {\"path\": fileEntry.path_display }\n          obj = JSON.stringify( obj) \n          console.log(obj)\n\n          const xhr = new XMLHttpRequest()\n          xhr.onreadystatechange = function(){\n               if (this.readyState == 4 && this.status == 200) {\n\n                    console.log('SUKCES', this.response, this.responseText)\n                    \n                    let img = document.querySelector('#preview')\n                    img.src = this.responseText\n                    //const URL = window.URL || window.webkitURL\n                    //img.src = URL.createObjectURL(this.response) \n\n               } else console.log('header', this.responseText, this.getAllResponseHeaders())\n          }\n          //xhr.open('POST','https://content.dropboxapi.com/2/files/get_thumbnail',true)\n          xhr.open('POST','https://api.dropboxapi.com/2/files/get_temporary_link', true)\n          xhr.setRequestHeader('Access-Control-Allow-Origin', '*')\n          xhr.setRequestHeader(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\n          //xhr.setRequestHeader('Access-Control-Allow-Headers', 'Content-Type');\n\n          xhr.setRequestHeader(\"Authorization\", \"Bearer x\")\n          //xhr.setRequestHeader(\"Dropbox-API-Arg\", obj)\n          //xhr.responseType = 'blob';\n          //xhr.send()\n          xhr.setRequestHeader('Content_Type','application/json')\n          \n          xhr.send(obj)\n     }\n*/\n\n\n\n\nfunction removeFormRatingChecked(){\n     const radios = document.querySelectorAll('input[type=\"radio\"][name=\"newRating\"]')\n     radios.forEach(radio=>radio.removeAttribute('checked') )\n}\nfunction nodeListToArray(list){\n     console.log(list)\n     let result = []\n     for (let item of list) result.push(item)\n     \n     return result\n}\nfunction getFormattedDate(date){\n     //console.log('typeof Date',typeof date, date)\n \n     if (typeof date == 'number') date = new Date(date)\n     else if (!date) date = new Date()\n \n     let year = date.getFullYear(),\n         month = date.getMonth()+1,\n         day = date.getDate(),\n         hours = date.getHours(),\n         minutes = date.getMinutes(),\n         secs = date.getSeconds()\n\n     const obj = {\n          year, month, day, hours, minutes, secs\n     }\n\n     for (let num in obj){\n          if (obj[num]<10) obj[num] =  String('0' + obj[num] ) \n     }\n\n     return `${obj.year}-${obj.month}-${obj.day}_T${obj.hours}-${obj.minutes}-${obj.secs}`\n}\n\n\nfunction animateLoader(){\n\n     const div = document.querySelector('#loader')\n     div.className = ''\n     this.animateLoader = true\n     let rot = 0\n\n     const animate = () => {\n          rot += 2\n          div.style.transform = `rotate(${rot}deg)`\n          if (this.animateLoader) requestAnimationFrame(animate)\n     }\n     animate()\n}\nfunction stopLoaderAnimation(){\n     \n     document.querySelector('#loader').className = 'nope'\n     const self = this\n\n     setTimeout(()=> self.animateLoader = false, 250)\n}\n\n\n\n\n\n/* templating attempt\n//import App from './templ1.Vue'\n//const tem1 = require('./templ1.Vue')\n//console.log(tem1)\n\nlet templ1 = new Vue({\n     el: '#templ1',\n     data: {\n          msg: 'hoho'\n     }\n     //render: h => h(App)\n})\n\nlet productTemplate = Vue.component('product',{\n     data:{\n          pname: 'jezisek'\n     },\n     props:{\n          pname: 'jezisek'\n     },\n     created:function(){\n          this.pname = 'babuska'\n     },\n     mounted:function(){\n          this.pname = 'babuska'\n     },\n     render:function(createElement){\n          return createElement(\n               'p',\n               `omg product ${this.pname} `\n               //this.$slots.default\n          )\n     }\n})*/"},"hash":"8a0d22ff47bae37b6346d8e7390a83f9"}