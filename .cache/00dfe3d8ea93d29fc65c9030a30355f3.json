{"dependencies":[],"generated":{"js":"/**\n *        simple state management http://vuetips.com/simple-state-management-vue-stash\n * \n */\n\n\n// for each product do display in DOM, use Component or template\n\n/**  DONE\n *   -    save last open locations to loc stor\n */\n\n'use strict'\n//import {addLocationToDB2} from './copy.js';\n//console.log('hey', typeof addLocationToDB2)\nlet somelet = 44\nconst funText = 'console.log(\"hi \" + somelet)'\nfunction fun(){\n\n     let somelet = 33\n     let f2 = new Function(funText) \n     let f3 = function(){\n          let somelet = 33\n          let f4 = new Function(funText) \n          return f4()\n     }\n     console.log(f3)\n     //hi = function(){ console.log('oh ' + somelet)} \n     return f3()    //hi()\n}\n//fun()\n\n\nconst initalCountryData = [{\n     name: 'all countries' , \n     cities: [\n               {\n                name: 'all cities', \n                shops:[{\n                         name: 'all shops',\n                         products: [{\"name\":\"časopis\"},{\"name\":\"denní tisk\"},{\"name\":\"česká igelitka\"}]\n                }]\n               }\n     ]\n}]\n\n\n\nwindow.otherUsers = []\n\n\nwindow.deviceUserData = new Dexie('deviceUserData')\n\nwindow.deviceUserData.version(1).stores({  userData: 'userName, countries'  })\nwindow.deviceUserData.open()\n     .then(data=>{\n               //console.log('open own DB, data:', data)\n     })\n     .catch(function(error) {\n               console.error('Uh oh : ' + error);\n     });\n\n\n\n\n\n\nconst users_followed = new Dexie('users_followed')\n\n     users_followed.version(1).stores({ userData: 'email, userName , countries'})\n     //const user1data = require('./testUserData1.json'), user2data = require('./testUserData2.json')\n     //users_followed.userData.put(user1data)\n     //users_followed.userData.put(user2data)\n\n\nconst serverURL = 'https://shopp.glitch.me/'\n\n\n\nconst app = new Vue({\n     el: '#app',\n     data: {\n          screen:'main',\n          showSignUp: false,\n          showLogin: false,\n          seeSignUp: false,\n          loginemail: null,\n          loginpass: null,\n\n          searchText: null,\n          searchResults: null,\n          followedUsers: [],\n\n          showSettings: false,\n          userName: undefined,\n          console: undefined,\n          locationInputShown: false,\n          locationSet: null,\n          newLocation: null,\n\n          currentCountry: null,\n          currentCity:  null,\n          currentShop:  null,\n          countries: [],\n          cities: [],\n          shops: [],\n          currentDisplayedProducts: [],\n\n          newProductForm: false\n     },\n     methods:{\n          switchScreen:function(screen){\n               this.screen = screen\n\n               if (screen =='main'){\n                    this.locationInputShown = false\n                    this.locationSet = null\n                    this.newLocation = null\n               }\n          },\n          showUserSettings:function(show){\n               this.showSettings = show;\n               if (show) this.screen = 'settings'\n               else this.screen = 'main'\n          },\n          login:function(){\n               let email = this.loginemail\n               let password = this.loginpass\n\n               console.log('longin', email, password)\n\n               const tosend = {email, password}, self = this\n\n               let xhr = new XMLHttpRequest()\n               xhr.onreadystatechange = function() {\n                    if (this.readyState == 4 && this.status == 200) {      console.log('received',typeof this.responseText, this.responseText)\n                              \n                              let loginResponse\n                              \n                         if (typeof this.responseText==='string') loginResponse = JSON.parse(this.responseText)\n\n                              window.localStorage.setItem('deviceUserEmail', email)\n                              updateDeviceUser(loginResponse.userName)\n                              \n                              if (loginResponse.followedUsers) \n                                   loginResponse.followedUsers.forEach(user=>addUserToDeviceLS(user))\n\n                              self.userName = loginResponse.userName\n                              self.screen = 'main'\n                              self.startApp()\n                              return self.log(`You rock'n'hop! logged iN`)\n\n                    } else if (this.readyState == 4 && this.status == 400){\n\n                         self.log(`something went wrong`)\n                    }\n               }\n               xhr.open(\"POST\", serverURL + \"API/login\", true)\n               xhr.send(JSON.stringify( tosend))\n\n          },\n          signUp: function($event){\n               $event.preventDefault()\n               let self = this\n                    let email = document.querySelector('input[name=\"reg-useremail\"').value\n                    let userName = document.querySelector('input[name=\"reg-username\"').value\n                    let password  = document.querySelector('input[name=\"reg-userpassword\"').value\n\n               if (userName==0) return alert(`sorry, '${userName}' can't be accepted as username`) // 0 is reserved for unregistered user in IDB\n\n               const tosend = {email, userName, password}\n               \n\n               if (!email || !userName || ! password) return console.error('email or name or pass missing')\n\n               let xhr = new XMLHttpRequest()\n               xhr.onreadystatechange = function() {\n                    \n                    if (this.readyState == 4 && this.status == 200) {  //this.responseText;\n                              //console.log(this.responseText,this.status)\n\n                              self.log(`You rock'n'b! Account created, check your email, spam etc`)\n                              window.localStorage.setItem('deviceUserEmail', email)\n                              createDeviceUser(username)\n                              self.getDeviceUser().then(name=>self.userName = name)\n                              self.screen = 'main'\n\n                    } else if (this.readyState == 4 && this.status ==400)\n\n                              self.log(`Email address '${email}' is already used..`)\n                    else {}\n\n                  };\n\n               xhr.open(\"POST\", serverURL + \"API/signup\", true)\n               //xhr.setRequestHeader('Access-Control-Allow-Origin', true)  //Access-Control-Allow-Origin\n               xhr.send(JSON.stringify( tosend))\n          },\n          logout: function($ev){\n               console.log('>> logouted <<')\n               \n               let items = ['deviceUserEmail', 'deviceUser', \n               'followedUsers', 'countries',\n               'cities', 'shops']\n\n               items.forEach(item=>\n                    //console.log('item to remove', item)\n                    window.localStorage.removeItem(item))\n               \n               this.userName = undefined\n\n               return this.startApp()\n          },\n          requestUsers:function(){\n               let string = this.searchText\n               const self = this\n               console.log('search for:', string)\n\n               const xhr = new XMLHttpRequest()\n               xhr.onreadystatechange = function(){\n                    if (this.readyState == 4 && this.status == 200) { \n\n                         console.log('recevide', this.responseText, typeof this.responseText)\n                         const users = JSON.parse(this.responseText)\n                         console.log(users)\n                         self.searchResults = users\n                    }\n               }\n               xhr.open('GET', serverURL + 'API/search?string=' + string + \"&useremail=\" + window.localStorage.getItem('deviceUserEmail'), true)\n               xhr.send( string)\n\n          },\n          log: function(msg){\n               this.console = msg\n\n               setTimeout(()=>{\n                    this.console = undefined\n               },5000)\n          },\n          followUser:function(email,userName){\n               console.log('follow', email,userName)\n               const self = this\n\n               const xhr = new XMLHttpRequest()\n               xhr.onreadystatechange = function(){\n\n                    if (this.readyState == 4 && this.status == 200) { \n                         console.log('follow sekces')\n                         // store new followdee in local storage\n                         addUserToDeviceLS({userName, email})\n\n                         fetchCountriesOfUser({userName, email})\n                         .then(setOtherUserIDBData)\n                         // then it should copy new data to deviceUser IDB??\n                         //\n                         .then(self.startApp)\n                         //.then(initializeCountriesState(self, countries))\n\n                    } else if (this.readyState == 4 && this.status == 400) { \n                         console.error('TRY AGAIN LATER')\n                         this.log('TRY AGAIN LATER')\n                         // finish this part\n                    }\n               }\n               xhr.open('POST', serverURL + 'API/followuser', true)\n               xhr.send(JSON.stringify({  email:email, \n                                          addTo: window.localStorage.getItem('deviceUserEmail')\n                                       })\n               )\n\n          },\n          isFollowed:function(email){\n                    let users = window.localStorage.getItem('followedUsers')\n                    users = JSON.parse(users)\n                    console.log(email, 'LS followed users', users)\n                    if (!users || users.some(user=>user.email== email)===false) return false\n                    else return true\n          },\n          unfollowUser:function(email){\n\n               // delete local storage country data of that user only if he isnt followed by any other deviceUser in IDB\n          },\n          /*getLocalStoredUsersData: function(){\n               return new Promise((resolve, reject)=>{\n                    getOtherUsersLocalData().then(result=>{\n                         //result = result.map(el=>el.countries)\n                         //console.log(result)\n                         if (result.length>0) resolve(result)\n                         else resolve(null)\n\n                    })\n               })   \n          },*/\n          openLocationInput: function(set,ev){\n               this.locationInputShown = true\n               //console.log('event', set, ev)\n               this.locationSet = `${set}`\n\n               if (this.locationSet=='city' && this.currentCountry == 'all countries') {\n                    alert('choose country first')\n                    return this.locationInputShown = false\n               }\n          },\n          addNewLocation: function(){\n               console.log(`new ${this.locationSet} is ${this.newLocation}`)\n               if (!this.newLocation) return alert('no name?');\n\n               const addLocation = addNewLocationToDB.bind(this)\n               \n               return addLocation(this.locationSet, this.newLocation)\n          },\n          updateLocationSelect:function(index, event){\n               //console.log('slct', event.srcElement.selectedIndex)\n               //console.log('label', event,'\\n', event.srcElement.getAttribute('data-saveas')  )\n\n               if (event.srcElement.selectedIndex<0) return      // protection against DOM load events ?\n\n               const self = this\n               const selects = ['countries', 'cities', 'shops','products'],\n                     currents= ['currentCountry','currentCity','currentShop']\n               \n               const name = event.srcElement.selectedOptions[0].text\n\n               setLastSelection(event.srcElement.getAttribute('data-saveas'), name)\n\n               \n               getSubsetItems(this,index,name)\n                    .then(userOwnProducts =>{  \n                         // save last locations to local storage rather here?\n                         console.log('----- user own products:', userOwnProducts.length, userOwnProducts)\n\n                         // get products from each user in IDB: for current city, shop etc\n                         getOtherUsersLocalData()\n                         .then(users=>{\n                              console.log('users to add products from', users)\n\n                              let finals = []\n                              if (userOwnProducts.length>0) \n                                   finals = [...userOwnProducts]\n\n                              console.log('finals1', finals.length)\n\n\n                              if (users){\n                                   let otherProds = users.map(user=>{\n\n                                        const countryI = user.countries.findIndex(cntry => cntry.name === self.currentCountry)\n\n                                        if (countryI > -1){\n                                             \n                                             const cityI = user.countries[countryI].cities.findIndex(city=>city.name === self.currentCity )\n                                             //console.log('cityI', cityI)\n                                             const shop = user.countries[countryI].cities[cityI].shops.find(shop=>shop.name===self.currentShop)\n                                             //console.log('shop', shop)\n                                             if (shop && shop.products) return shop.products\n                                        }\n                                   }).filter(prods=>prods!==undefined)\n\n                                   console.log('|||| to add', Array.isArray(otherProds), otherProds)\n\n                                   if (otherProds.length>0) finals = finals.concat(...otherProds)\n                              }\n                              \n                              console.log('finals2', finals.length)\n                              // displays products on screen\n                              this.currentDisplayedProducts = finals//[...finals]\n\n                              return console.log('curr prods',this.currentDisplayedProducts)\n                         })\n                    })\n               function getSubsetItems(self, outerIndex, name){\n                    \n                    if (outerIndex>4) return false;\n\n                    //console.log('getting items of', name)\n                    //console.log('continue -- outerIndex, name',outerIndex, name)\n                    return new Promise((resolve, rej)=>{\n                         // 0 1 2\n                         const currentX = currents[outerIndex]  // 'currentCountry' 'currentCity' 'currentShop'\n                         const index = outerIndex,\n                               superSet = selects[index-1], // 'countries' 'cities' 'shops'\n                               set      = selects[index],   // 'countries' 'cities' 'shops'\n                               subSet   = selects[index+1]  // 'countries' 'cities' 'shops'\n                               \n                         //console.log('self[currentX]', currentX, self[currentX])\n                         //console.log('set', set)\n\n                         //const name = event.srcElement.selectedOptions[0].text\n                         if (set == 'products'){\n                              //console.log('products', subSet, a.name, a[subSet], a.products)\n                              //console.log('PRODUCTS!!!  ', a.products)\n                              //resolve( getSubsetItems(self, outerIndex + 1, 'products') )\n                              return alert('oops')\n                         }\n\n                         let a = self[set].find(el=>{ return el.name===name })\n                         \n                         \n\n                         self[currentX] = name\n                         console.log(currentX, name)\n                         //console.log('    save ?', set, name)\n                         setLastSelection(set, name)\n\n                         self[subSet] = a[subSet]\n                         //console.log(`subset`, a[subSet])\n                         //console.log('subSet', subSet)\n                         \n                         //console.log('---',currents[outerIndex+1])\n                         if (currents[outerIndex+1]=== undefined) {\n                              //console.log('products?', a.name, a[subSet])\n                              resolve(a[subSet]) \n                              return //console.log('test')\n                         }\n\n                         let string = currents[outerIndex+1].toString()\n                         self[string]= a[subSet][0].name    // 'currentCountry' 'currentCity' 'currentShop'\n                         \n                         //console.log('[subSet]', self[subSet][0])  // name of default item to set\n                         \n                         resolve(\n                              getSubsetItems(self, outerIndex + 1, a[subSet][0].name)          \n                         )\n                    })\n               }\n          },\n          openNewProductForm:function(open){\n               this.newProductForm = open\n          },\n          newProductSubmit: function($event){\n               $event.preventDefault()\n               \n               //const form = document.querySelector('form[name=\"newProductForm\"')\n               const rating = document.querySelector('input[name=\"newRating\"]:checked').value\n\n               const fileName = `${this.userName}_D${getFormattedDate(null)}`\n               console.log('submit', fileName)\n          },\n          startApp:function(){\n               //this.screen = 'main'\n\n               this.userName = getDeviceUser()\n               //if (this.userName===null) this.userName = 'null'  // because of IDB so user can be found, it doesnt store null as value\n               console.log('userName', this.userName)\n               \n               if (this.userName!==undefined){ \n                    this.followedUsers = getLSfollowedUsers() \n               }\n               console.log('followedUsers', this.followedUsers)\n               // try to update followdees data in IDB from MDB (if online)\n               \n               getOwnDBData(this.userName)\n               .then( ownCountries =>{\n                    console.log('resolved length:',ownCountries.length, ownCountries)\n\n                    // try to get MDB data to update LocSto\n                    if (navigator.onLine){\n                         /*this.followedUsers.forEach(user=>{\n                              fetchUserCountries(user)\n                         })*/\n\n                    } else {}\n\n                    //let somethingChanged = false\n                    if (!this.userName) return initializeCountriesState(this, ownCountries)\n                    //else return console.log('can follow others')\n\n                    getOtherUsersLocalData()\n                    .then(users=>{\n                         \n                         console.log('my own', ownCountries)\n                         console.log('users', users)\n                         \n                         if (!users){\n                              console.log('NO FOLLOWED USERS')\n                              return initializeCountriesState(this, ownCountries)\n                         }\n                         let somethingChanged = false,\n                             own = [...ownCountries],\n                             Users = users.map(user=>user.countries)\n                         console.log('users', Users)\n\n                         // copies all others' locations to save them in IDB of device\n                         copyUserData(Users, own)\n                         .then(final=>{\n                                   console.log('somethingChanged? ',somethingChanged)\n                                   if (somethingChanged) console.log('location data to save', final===own, final)\n\n                                   // save each country without prods to device user IDB\n                                   if (somethingChanged) {\n                                        updateDeviceUserCountries(this.userName, final)   // store everything to deviceUser IDB\n                                        .then(initializeCountriesState(this, final))      // update screen w new data available\n\n                                   } else return initializeCountriesState(this, final)\n                                   //final.forEach( country => deviceUserData.countries.put(country) )\n                         })\n\n\n                         function copyUserData(users, owndata){\n                              console.log('EQUAL', ownCountries == owndata)\n                              \n                              return new Promise((resolve, reject)=>{\n                                   const sets = ['countries','cities','shops','products']\n                                   let index = 0\n                                   users.forEach(other_countries => {\n\n                                             // remove products from each country\n                                             const others_cleaned = other_countries.map( country => removeProducts(country,0))     \n\n                                             copyEntries(index, owndata, others_cleaned)\n\n                                             .then(newCountries=> resolve(newCountries) )  \n                                   })\n\n                                   function removeProducts(entry,index){\n                                        //if (index>3) return;\n\n                                        if (entry.hasOwnProperty('products')){\n                                             //console.log('in SHOP', entry.name)\n                                             return {name: entry.name, products: []} //entry.products = []\n\n                                        } else if (entry.name){\n                                             //console.log('|||| not shop', index, entry.name, sets[index])\n                                             let name = entry.name\n                                             let prop = sets[index+1]  // cities shops\n                                             let y \n                                             entry[prop] = entry[prop].map(entry => {\n                                                            //console.log('-- going into',entry.name, sets[index+1])\n                                                            return removeProducts(entry, index+1)\n                                                           })\n                                             //console.log('filtered ',prop,'of',entry.name, entry[prop])\n                                             return entry\n                                        } \n                                   }\n                                   function copyEntries(outerIndex, ownEntries, otherEntries){\n                                        \n                                        function emptyspace(ind){\n                                                  let spaces = \"\", len = ind*5\n                                                  for (let i=0; i<len; i++){\n                                                       spaces = spaces.concat(\" \")\n                                                  }\n                                                  return spaces\n                                        }\n                                        let index = outerIndex +1\n                                        let set = sets[outerIndex], subset = sets[index]\n                                        //console.log(emptyspace(outerIndex),'index', index, set, subset)\n                                        // if its shops now\n\n                                        return new Promise((resolve,rej)=>{\n                                             otherEntries.forEach(other_entry=>{\n                                                  \n                                                  //console.log( emptyspace(outerIndex),`checking others '${other_entry.name}'`)\n\n                                                  if (ownEntries.some(ownEntry=> ownEntry.name == other_entry.name)=== false ) {\n                                                       // not on device -> add it there\n                                                       //console.log(emptyspace(outerIndex),set, 'NOT THERE -> ADDING ',other_entry.name )\n                                                        //console.log(emptyspace(outerIndex),'- doing -', other_entry.name) \n                                                        //let locations = removeProducts( other_entry, index)\n                                                        //console.log('without products',set, locations, subset)\n                                                        //other_entry[subset] = location\n                                                       ownEntries.push(other_entry)\n                                                       somethingChanged = true\n                                                        //console.log(other_entry.name,'updated?',other_entry)\n                                                        //console.log( other_entry.name, 'updated?',locations )\n\n                                                  // if this entry is already there\n                                                  } else{\n                                                       ownEntries.forEach( own_entry=>{\n                                                            //console.log(emptyspace(outerIndex),'checking >>>',subset, 'of',own_entry.name, own_entry)\n                                                            //console.log(emptyspace(outerIndex),set, 'is there checking >>>',own_entry.name, own_entry)\n                                                            // take others subentries and add them to Own\n                                                            if (own_entry.name === other_entry.name){\n                                                                 //console.log(emptyspace(outerIndex),`duplicates ${own_entry.name} = ${other_entry.name}`)\n                                                                 //console.log(emptyspace(outerIndex),index, 'subset',subset,'<<')\n                                                                 if (index<3)//subset!==undefined) // if subset is undefined, can it even reach this deep? i.e. - if the condition neccessary\n                                                                 copyEntries(index, own_entry[subset], other_entry[subset] )\n\n                                                                 else if (subset===undefined) {\n                                                                      \n                                                                      //console.log(emptyspace(outerIndex),'??',own_entry)\n                                                                      //let smt = removeProducts(own_entry,index)\n                                                                      //console.log(emptyspace(outerIndex),'done ------- with', set)\n                                                                 }\n                                                            } //it gets added above\n                                                       })\n                                                  }\n                                             })\n                                             resolve(ownEntries)\n                                        })\n                                   }\n                              })\n                         }\n                    })\n               })\n               .catch( er => {\n                    \n                    if (er===null){  //console.log('- - - will initialize Country data')\n                         \n                         storeInitialDBData(this.userName)\n                         .then( data =>{\n                              console.log('- - - stored?', data)\n                              initializeCountriesState(this, initalCountryData)\n                              //this.startApp()\n                         })\n\n                    } else \n                         console.error('!!!!!  there was real error\\n error getting init data',er)\n               })\n          \n     \n          }\n     },\n     mounted: function(){\n          window.initializeCountriesState = initializeCountriesState.bind(this)  // its used on few occasions w different contexts\n          this.startApp()\n     },\n     created:function(){\n          //console.log('CREATED')\n     }\n})\n\n\n\n\nfunction addNewLocationToDB(set, newName){\n     console.log('add', set)\n     //   under what country to add it\n     //   should i update whole country document?\n     let somethingChanged = '333' //false\n     const copyData = new Function('users', 'owndata', copyUserData_text)\n     const self = this\n     \n     let toSave\n\n     if (set =='country'){\n                    console.log(`this happens 1`)\n                    let index = this.countries.findIndex(country=>country.name == newName)\n\n                    if (index>-1) { return alert(`'${newName}' is already in your database`) }\n\n                    const newCountry = \n                              [{   name: newName, \n                                   cities: [{\n                                        name: 'all cities', \n                                        shops:[{\n                                             name: 'all shops',\n                                             products: []\n                                        }]\n                                   }]\n                              }]\n                    \n                    toSave = [newCountry]\n                    \n\n     } else if (set =='city') { console.log(`this happens 1`)\n\n               let countryData = this.countries.find(cntry=> cntry.name == this.currentCountry)\n               \n               // check if this city is already there\n               let index = countryData.cities.findIndex(city=>city.name == newName)\n\n               if (index>-1){ return alert(`'${newName}' is already in your database`) }\n               \n\n               countryData.cities.push({\n                                   name: newName, \n                                   shops:[{\n                                        name: 'all shops',\n                                        products: []\n                                   }]\n               })\n               console.log( '   adding city',\"\\n\",countryData)\n               console.log( '   original',\"\\n\",this.countries)\n\n               toSave = [[countryData]]\n\n     } else if (set =='shop') {  console.log(`this happens 1`)\n\n          let countryData = this.countries.find(cntry=> cntry.name ===this.currentCountry)\n          \n          let cityData = countryData.cities.find(city=> city.name === this.currentCity)\n          console.log( '   adding shop ', newName, 'to', cityData.name)\n\n          // check its not there already\n          if (cityData.shops.findIndex(shop=>shop.name===newName) > -1)\n                    return alert(`'${newName}' is already in your database`)\n          \n\n          cityData.shops.push(\n                                   {\n                                     name: newName,\n                                     products: []\n                                   }\n                              )\n\n          console.log('   new entry now', this.currentCountry, countryData)\n          \n          toSave = [[countryData]]\n          \n          /*window.deviceUserData.countries.put(countryData).then(status => {\n                                   console.log('   updated Vue data',this.countries) \n                                   this.getOwnDBData().then(data => this.countries = data) // then select newly added thing\n          })*/\n\n     }\n     console.log(`this happens last`)\n     \n\n     copyData( toSave, [...this.countries] )\n\n     .then(final=>{\n               console.log('location data to save', final===this.countries, final)\n\n               return updateDeviceUserCountries(this.userName, final)\n                         \n     }).then(result=>{\n               console.log('result', result)\n               return initializeCountriesState(this, result)\n     })\n\n\n\n     return this.switchScreen('main')\n}\n\n\nfunction fetchCountriesOfUser(user){\n\n     return new Promise((resolve, reject)=>{\n          console.log(`geeting data of ${user.email}`)\n\n          const xhr = new XMLHttpRequest()\n          xhr.onreadystatechange = function(){\n               if (this.readyState == 4 && this.status == 200) {     // console.log(this.status,'received',typeof this.responseText)\n\n                         const result = JSON.parse(this.responseText)\n                         result.userName = user.userName\n\n                         //console.log(result.email, typeof result, result)\n                         resolve(result)\n\n               } else if (this.readyState == 4 && this.status!=200) reject()\n          }\n          xhr.open('POST',serverURL + 'API/getCountriesOfUser',true)\n          xhr.send(user.email)\n     })\n}\nfunction setOtherUserIDBData(allData){\n     console.log('allData to IDB >', allData)\n     return new Promise((resolve, reject)=>{\n\n          users_followed.userData.put(allData)\n          .then(result=>{\n               console.log(result)  // this returns primary key i.e. email\n               resolve()\n          }).catch(er=>{\n               console.error(er)\n               reject()\n          })\n     })\n}\n\nfunction setLastSelection(set, value){\n     //console.log('>> saving', set, value)\n     window.localStorage.setItem(set, value.toString() )\n}\nfunction getLastSelection(set){\n     \n     let val = window.localStorage.getItem(set)\n     //console.log('requested', set, val)\n     return val\n}\n\nfunction getFormattedDate(date){\n     //console.log('typeof Date',typeof date, date)\n \n     if (typeof date === 'number' || !date){\n         date = new Date()\n         //var d = new Date();\n         //d.setTime(1332403882588);\n         //console.log(date)\n     }\n \n     let year = date.getFullYear(),\n         month = date.getMonth()+1,\n         day = date.getDate(),\n         hours = date.getHours(),\n         minutes = date.getMinutes(),\n         secs = date.getSeconds()\n\n     const obj = {\n          year, month, day, hours, minutes, secs\n     }\n\n     for (let num in obj){\n          if (obj[num]<10) obj[num] =  String('0' + obj[num] ) \n     }\n\n     return `${obj.year}-${obj.month}-${obj.day}_T${obj.hours}-${obj.minutes}-${obj.secs}`\n}\n\nfunction getLSfollowedUsers(){\n     let users = window.localStorage.getItem('followedUsers')\n     users = JSON.parse(users)\n     return users\n}\nfunction addUserToDeviceLS(newUser){\n\n     let users = window.localStorage.getItem('followedUsers')\n     users = JSON.parse(users)\n\n     if (users===null) users = [newUser]\n     else if (users.some(user=>user.email==newUser.email)===false) users.push(newUser) // add new user only if he isnt there yet\n\n     console.log('LS users now', users)\n\n     return window.localStorage.setItem('followedUsers', JSON.stringify(users))\n}\n\n//createDeviceUser('app Owner')\nfunction updateDeviceUser(name = 0){\n     //if ( window.localStorage.getItem('deviceUser') === null){\n          name = name.toString().trim()\n\n          const initialData = {\n               userName: name, \n               createdDate: getFormattedDate(null)\n          } \n          window.localStorage.setItem('deviceUser', JSON.stringify(initialData)) \n     //}\n     console.log('created user', window.localStorage.getItem('deviceUser') )\n}\n\nfunction getDeviceUser(){\n\n          let data = JSON.parse(window.localStorage.getItem('deviceUser'))\n          if (data) return data.userName\n          else return undefined\n}\n\nfunction getOwnDBData(user = 0){\n     console.log(`getting data of ${user}`)\n\n     return new Promise((resolve, reject)=>{\n\n          //console.log('test1',deviceUserData.userData.userName)\n\n          /*if (deviceUserData.userData===undefined) {\n               console.log('!! 1st condition')\n               return reject(null)\n          }*/\n\n          deviceUserData.userData.get({userName:user})//.toArray()   // https://dexie.org/docs/Table/Table.get()\n          .then(data => {\n               if (data==undefined) {\n                    console.log('no data, probably initializing app?')\n                    return reject(null)\n               } \n\n               const res = data.countries\n               \n               if (Array.isArray(res)) resolve(res)\n\n               else if (res.hasOwnProperty('name')){\n                    console.log('got only initial data')\n                    resolve([res])\n               }\n          })\n          .catch(er => {\n               console.log('||||||||||  er',er)\n               reject(er) \n          })\n     })\n}\n\nfunction storeInitialDBData(userName = 0){\n     console.log(`storing data for ${userName}`)\n     return new Promise((resolve, reject)=>{\n          //console.log(window.deviceUserData.userData)\n          \n          deviceUserData.userData.put({userName, countries: initalCountryData})\n\n          .then(all=>{\n                    console.log('stored initial data:', all,\"<<\")\n                    resolve(all)\n          })                         \n          .catch(er=>{\n               console.error(er);\n               reject(er)\n          })\n     })\n}\n\nfunction getOtherUsersLocalData(){\n\n     return new Promise((res,rej)=>{\n               \n          users_followed.open(x=>{\n               console.log('x',x)\n               return //x.userData.toArray()\n          })\n          .then(()=>users_followed.userData.toArray())\n          .then(users =>{ \n               //console.log('otherUsers',users)\n               if (users.length==0) res(null)\n               else res(users)\n\n          })\n          .catch(er=>alert('error opening following', er))\n     })\n}\n\nfunction initializeCountriesState(self, countries){\n     console.log('initializing countries\\n')\n\n     //it doesnt seem to reflect the content unless its refreshed by user\n\n     self.countries = countries\n     self.currentCountry = getLastSelection('countries') || 'all countries'\n     //console.log(self.currentCountry, self.countries)\n     //self.updateLocationSelect('countries','cities',undefined, self.currentCountry.toString() )\n\n     // city\n     let lastCntry = countries.find(cn=>cn.name=== self.currentCountry)\n     self.cities = lastCntry.cities\n     //console.log('self.cities',self.cities)\n\n     self.currentCity =  self.cities.find(city => city.name ==  getLastSelection('cities') || 'all cities' )\n     self.currentCity = self.currentCity.name\n     //console.log(self.currentCity)\n\n     // shop\n     let lastCity = self.cities.find(city => city.name === self.currentCity )\n     self.shops = lastCity.shops\n     self.currentShop =  getLastSelection('shops')  || 'all shops'\n     //console.log(self.currentShop)\n\n     self.currentDisplayedProducts = self.shops.find(shop=>shop.name === self.currentShop).products\n     //console.log('curr prods',self.currentDisplayedProducts)\n}\n\n\n\nfunction copyUserData(users, owndata){\n     console.log('EQUAL', users, owndata)\n     //console.log('copying', somethingChanged)//users, owndata)\n     \n     return new Promise((resolve, reject)=>{\n          const sets = ['countries','cities','shops','products']\n          let index = 0\n          users.forEach(other_countries => {\n\n                    // remove products from each country\n                    const others_cleaned = other_countries.map( country => removeProducts(country,0))     \n\n                    copyEntries(index, owndata, others_cleaned)\n\n                    .then(newCountries=> resolve(newCountries) )  \n          })\n\n          function removeProducts(entry,index){\n               //if (index>3) return;\n\n               if (entry.hasOwnProperty('products')){\n                    //console.log('in SHOP', entry.name)\n                    return {name: entry.name, products: []} //entry.products = []\n\n               } else if (entry.name){\n                    //console.log('|||| not shop', index, entry.name, sets[index])\n                    let name = entry.name\n                    let prop = sets[index+1]  // cities shops\n                    let y \n                    entry[prop] = entry[prop].map(entry => {\n                                   //console.log('-- going into',entry.name, sets[index+1])\n                                   return removeProducts(entry, index+1)\n                                  })\n                    //console.log('filtered ',prop,'of',entry.name, entry[prop])\n                    return entry\n               } \n          }\n          function copyEntries(outerIndex, ownEntries, otherEntries){\n               \n               function emptyspace(ind){\n                         let spaces = \"\", len = ind*5\n                         for (let i=0; i<len; i++){\n                              spaces = spaces.concat(\" \")\n                         }\n                         return spaces\n               }\n               let index = outerIndex +1\n               let set = sets[outerIndex], subset = sets[index]\n               //console.log(emptyspace(outerIndex),'index', index, set, subset)\n               // if its shops now\n\n               return new Promise((resolve,rej)=>{\n                    otherEntries.forEach(other_entry=>{\n                         \n                         //console.log( emptyspace(outerIndex),`checking others '${other_entry.name}'`)\n\n                         if (ownEntries.some(ownEntry=> ownEntry.name == other_entry.name)=== false ) {\n                              // not on device -> add it there\n                              //console.log(emptyspace(outerIndex),set, 'NOT THERE -> ADDING ',other_entry.name )\n                               //console.log(emptyspace(outerIndex),'- doing -', other_entry.name) \n                               //let locations = removeProducts( other_entry, index)\n                               //console.log('without products',set, locations, subset)\n                               //other_entry[subset] = location\n                              ownEntries.push(other_entry)\n                              somethingChanged = true\n                               //console.log(other_entry.name,'updated?',other_entry)\n                               //console.log( other_entry.name, 'updated?',locations )\n\n                         // if this entry is already there\n                         } else{\n                              ownEntries.forEach( own_entry=>{\n                                   //console.log(emptyspace(outerIndex),'checking >>>',subset, 'of',own_entry.name, own_entry)\n                                   //console.log(emptyspace(outerIndex),set, 'is there checking >>>',own_entry.name, own_entry)\n                                   // take others subentries and add them to Own\n                                   if (own_entry.name === other_entry.name){\n                                        //console.log(emptyspace(outerIndex),`duplicates ${own_entry.name} = ${other_entry.name}`)\n                                        //console.log(emptyspace(outerIndex),index, 'subset',subset,'<<')\n                                        if (index<3)//subset!==undefined) // if subset is undefined, can it even reach this deep? i.e. - if the condition neccessary\n                                        copyEntries(index, own_entry[subset], other_entry[subset] )\n\n                                        else if (subset===undefined) {\n                                             \n                                             //console.log(emptyspace(outerIndex),'??',own_entry)\n                                             //let smt = removeProducts(own_entry,index)\n                                             //console.log(emptyspace(outerIndex),'done ------- with', set)\n                                        }\n                                   } //it gets added above\n                              })\n                         }\n                    })\n                    resolve(ownEntries)\n               })\n          }\n     })\n}\n\n\nfunction updateDeviceUserCountries(userName=0, countries){\n     //console.log(`save to user: ${userName} ${countries}`)\n     let obj = {userName, countries }\n     //console.log(obj)\n     return new Promise((resolve, reject)=>{\n\n          deviceUserData.userData.put({ userName, countries })\n          .then(result=>{\n               console.log(result)\n               resolve(countries)\n\n          }).catch(er=>{})\n     })\n     \n}\nconst copyUserData_text = `\n     console.log('newdata, owndata', users, owndata)\n     //console.log('copying', somethingChanged)//users, owndata)\n\n     return new Promise((resolve, reject)=>{\n          const sets = ['countries','cities','shops','products']\n          let index = 0\n          users.forEach(other_countries => {\n                    console.log(other_countries)\n                    // remove products from each country  \n                    // not if its used to store new location\n                    //const others_cleaned = other_countries//.map( country => removeProducts(country,0))     \n\n                    copyEntries(index, owndata, other_countries)//others_cleaned)\n\n                    .then(newCountries=> resolve(newCountries) )  \n          })\n\n          function removeProducts(entry,index){\n               //if (index>3) return;\n\n               if (entry.hasOwnProperty('products')){\n                    //console.log('in SHOP', entry.name)\n                    return {name: entry.name, products: []} //entry.products = []\n\n               } else if (entry.name){\n                    //console.log('|||| not shop', index, entry.name, sets[index])\n                    let name = entry.name\n                    let prop = sets[index+1]  // cities shops\n                    let y \n                    entry[prop] = entry[prop].map(entry => {\n                                   //console.log('-- going into',entry.name, sets[index+1])\n                                   return removeProducts(entry, index+1)\n                              })\n                    //console.log('filtered ',prop,'of',entry.name, entry[prop])\n                    return entry\n               } \n          }\n          function copyEntries(outerIndex, ownEntries, otherEntries){\n               \n               function emptyspace(ind){\n                         let spaces = \"\", len = ind*5\n                         for (let i=0; i<len; i++){\n                              spaces = spaces.concat(\" \")\n                         }\n                         return spaces\n               }\n               let index = outerIndex +1\n               let set = sets[outerIndex], subset = sets[index]\n               //console.log(emptyspace(outerIndex),'index', index, set, subset)\n               // if its shops now\n\n               return new Promise((resolve,rej)=>{\n                    otherEntries.forEach(other_entry=>{\n                         \n                         if (ownEntries.some(ownEntry=> ownEntry.name == other_entry.name)=== false ) {\n                              // not on device -> add it there\n                              console.log(emptyspace(outerIndex),set, 'NOT THERE -> ADDING ',other_entry.name )\n                              //console.log(emptyspace(outerIndex),'- doing -', other_entry.name) \n                              //let locations = removeProducts( other_entry, index)\n                              //console.log('without products',set, locations, subset)\n                              //other_entry[subset] = location\n                              ownEntries.push(other_entry)\n                              //console.log(somethingChanged)\n                              //if (somethingChanged!=undefined) somethingChanged = true\n                              //console.log(other_entry.name,'updated?',other_entry)\n                              //console.log( other_entry.name, 'updated?',locations )\n\n                         // if this entry is already there\n                         } else{\n                              ownEntries.forEach( own_entry=>{\n                                   //console.log(emptyspace(outerIndex),'checking >>>',subset, 'of',own_entry.name, own_entry)\n                                   //console.log(emptyspace(outerIndex),set, 'is there checking >>>',own_entry.name, own_entry)\n                                   // take others subentries and add them to Own\n                                   if (own_entry.name === other_entry.name){\n                                        //console.log(emptyspace(outerIndex),index, 'subset',subset,'<<')\n                                        if (index<3)//subset!==undefined) // if subset is undefined, can it even reach this deep? i.e. - if the condition neccessary\n                                        copyEntries(index, own_entry[subset], other_entry[subset] )\n\n                                        else if (subset===undefined) {\n                                             \n                                             //console.log(emptyspace(outerIndex),'??',own_entry)\n                                             //let smt = removeProducts(own_entry,index)\n                                             //console.log(emptyspace(outerIndex),'done ------- with', set)\n                                        }\n                                   } //it gets added above\n                              })\n                         }\n                    })\n                    resolve(ownEntries)\n               })\n          }\n     })`\n//\n"},"hash":"5f97590aaa0a04d270b0061f0fc066ed"}